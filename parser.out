Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl program
Rule 2     program -> empty
Rule 3     empty -> <empty>
Rule 4     class_decl -> CLASS ID found_class_name extends_class LCURLY class_body_decl RCURLY
Rule 5     found_class_name -> <empty>
Rule 6     extends_class -> EXTENDS ID
Rule 7     extends_class -> empty
Rule 8     class_body_decl -> class_body_decl_type class_body_decl
Rule 9     class_body_decl -> class_body_decl_type
Rule 10    class_body_decl_type -> field_decl
Rule 11    class_body_decl_type -> method_decl
Rule 12    class_body_decl_type -> constructor_decl
Rule 13    field_decl -> modifier var_decl
Rule 14    modifier -> visibility optional_static
Rule 15    visibility -> PUBLIC
Rule 16    visibility -> PRIVATE
Rule 17    visibility -> empty
Rule 18    optional_static -> STATIC
Rule 19    optional_static -> empty
Rule 20    var_decl -> type variables SEMICOLON
Rule 21    type -> INT
Rule 22    type -> FLOAT
Rule 23    type -> BOOLEAN
Rule 24    type -> VOID
Rule 25    type -> NULL
Rule 26    type -> ID
Rule 27    variables -> variable additional_vars
Rule 28    variable -> ID
Rule 29    additional_vars -> COMMA variable additional_vars
Rule 30    additional_vars -> empty
Rule 31    method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block
Rule 32    found_method_type -> <empty>
Rule 33    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 34    formals -> formal_param additional_formal_params
Rule 35    formals -> empty
Rule 36    formal_param -> type variable
Rule 37    additional_formal_params -> COMMA formal_param additional_formal_params
Rule 38    additional_formal_params -> empty
Rule 39    block -> LCURLY new_scope stmt_section RCURLY
Rule 40    new_scope -> <empty>
Rule 41    stmt_section -> stmt stmt_section
Rule 42    stmt_section -> empty
Rule 43    stmt -> if_stmt
Rule 44    stmt -> while_stmt
Rule 45    stmt -> for_stmt
Rule 46    stmt -> return_stmt
Rule 47    stmt -> stmt_expr SEMICOLON
Rule 48    stmt -> BREAK SEMICOLON
Rule 49    stmt -> CONTINUE SEMICOLON
Rule 50    stmt -> block
Rule 51    stmt -> var_decl
Rule 52    stmt -> SEMICOLON
Rule 53    if_stmt -> IF LPAREN expr RPAREN stmt else_stmt
Rule 54    else_stmt -> ELSE stmt
Rule 55    else_stmt -> empty
Rule 56    while_stmt -> WHILE LPAREN expr RPAREN stmt
Rule 57    for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
Rule 58    return_stmt -> RETURN optional_expr SEMICOLON
Rule 59    optional_stmt_expr -> stmt_expr
Rule 60    optional_stmt_expr -> empty
Rule 61    optional_expr -> expr
Rule 62    optional_expr -> empty
Rule 63    stmt_expr -> assign_expr
Rule 64    stmt_expr -> method_invocation
Rule 65    expr -> primary_expr
Rule 66    expr -> assign_expr
Rule 67    expr -> arith_expr
Rule 68    expr -> bool_expr
Rule 69    expr -> unary_expr
Rule 70    primary_expr -> literal
Rule 71    primary_expr -> THIS
Rule 72    primary_expr -> SUPER
Rule 73    primary_expr -> LPAREN expr RPAREN
Rule 74    primary_expr -> new_object
Rule 75    primary_expr -> left_hand_side
Rule 76    primary_expr -> method_invocation
Rule 77    literal -> INT_CONST
Rule 78    literal -> FLOAT_CONST
Rule 79    literal -> STRING
Rule 80    literal -> NULL
Rule 81    literal -> TRUE
Rule 82    literal -> FALSE
Rule 83    new_object -> NEW ID LPAREN arguments RPAREN
Rule 84    left_hand_side -> field_access
Rule 85    field_access -> primary_expr DOT ID
Rule 86    field_access -> ID
Rule 87    method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN
Rule 88    arguments -> expr additional_exprs
Rule 89    arguments -> empty
Rule 90    additional_exprs -> COMMA expr additional_exprs
Rule 91    additional_exprs -> empty
Rule 92    assign_expr -> left_hand_side ASSIGN_OP expr
Rule 93    assign_expr -> left_hand_side INCREMENT
Rule 94    assign_expr -> INCREMENT left_hand_side
Rule 95    assign_expr -> left_hand_side DECREMENT
Rule 96    assign_expr -> DECREMENT left_hand_side
Rule 97    arith_expr -> expr PLUS expr
Rule 98    arith_expr -> expr MINUS expr
Rule 99    arith_expr -> expr MULTIPLY expr
Rule 100   arith_expr -> expr DIVIDE expr
Rule 101   bool_expr -> expr AND expr
Rule 102   bool_expr -> expr OR expr
Rule 103   bool_expr -> expr EQUAL_TO expr
Rule 104   bool_expr -> expr NOT_EQUAL_TO expr
Rule 105   bool_expr -> expr LESS_THAN expr
Rule 106   bool_expr -> expr GREATER_THAN expr
Rule 107   bool_expr -> expr LESS_OR_EQUAL_TO expr
Rule 108   bool_expr -> expr GREATER_OR_EQUAL_TO expr
Rule 109   unary_expr -> PLUS expr
Rule 110   unary_expr -> MINUS expr
Rule 111   unary_expr -> NEGATION expr

Terminals, with rules where they appear

AND                  : 101
ASSIGN_OP            : 92
BOOLEAN              : 23
BREAK                : 48
CLASS                : 4
COMMA                : 29 37 90
COMMENT              : 
CONTINUE             : 49
DECREMENT            : 95 96
DIVIDE               : 100
DO                   : 
DOT                  : 85 87
ELSE                 : 54
EQUAL_TO             : 103
EXTENDS              : 6
FALSE                : 82
FLOAT                : 22
FLOAT_CONST          : 78
FOR                  : 57
GREATER_OR_EQUAL_TO  : 108
GREATER_THAN         : 106
ID                   : 4 6 26 28 31 33 83 85 86 87
IF                   : 53
INCREMENT            : 93 94
INT                  : 21
INT_CONST            : 77
LCURLY               : 4 39
LESS_OR_EQUAL_TO     : 107
LESS_THAN            : 105
LPAREN               : 31 33 53 56 57 73 83 87
MINUS                : 98 110
MULTIPLY             : 99
NEGATION             : 111
NEW                  : 83
NOT_EQUAL_TO         : 104
NULL                 : 25 80
OR                   : 102
PLUS                 : 97 109
PRIVATE              : 16
PUBLIC               : 15
RCURLY               : 4 39
RETURN               : 58
RPAREN               : 31 33 53 56 57 73 83 87
SEMICOLON            : 20 47 48 49 52 57 57 58
STATIC               : 18
STRING               : 79
SUPER                : 72
THIS                 : 71
TRUE                 : 81
VOID                 : 24
WHILE                : 56
error                : 

Nonterminals, with rules where they appear

additional_exprs     : 88 90
additional_formal_params : 34 37
additional_vars      : 27 29
arguments            : 83 87
arith_expr           : 67
assign_expr          : 63 66
block                : 31 33 50
bool_expr            : 68
class_body_decl      : 4 8
class_body_decl_type : 8 9
class_decl           : 1
constructor_decl     : 12
else_stmt            : 53
empty                : 2 7 17 19 30 35 38 42 55 60 62 89 91
expr                 : 53 56 61 73 88 90 92 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 104 105 105 106 106 107 107 108 108 109 110 111
extends_class        : 4
field_access         : 84
field_decl           : 10
for_stmt             : 45
formal_param         : 34 37
formals              : 31 33
found_class_name     : 4
found_method_type    : 31
if_stmt              : 43
left_hand_side       : 75 92 93 94 95 96
literal              : 70
method_decl          : 11
method_invocation    : 64 76
modifier             : 13 31 33
new_object           : 74
new_scope            : 39
optional_expr        : 57 58
optional_static      : 14
optional_stmt_expr   : 57 57
primary_expr         : 65 85 87
program              : 1 0
return_stmt          : 46
stmt                 : 41 53 54 56 57
stmt_expr            : 47 59
stmt_section         : 39 41
type                 : 20 31 36
unary_expr           : 69
var_decl             : 13 51
variable             : 27 29 36
variables            : 20
visibility           : 14
while_stmt           : 44

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl program
    (2) program -> . empty
    (4) class_decl -> . CLASS ID found_class_name extends_class LCURLY class_body_decl RCURLY
    (3) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 3 (empty -> .)

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class_decl . program
    (1) program -> . class_decl program
    (2) program -> . empty
    (4) class_decl -> . CLASS ID found_class_name extends_class LCURLY class_body_decl RCURLY
    (3) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 3 (empty -> .)

    class_decl                     shift and go to state 2
    program                        shift and go to state 5
    empty                          shift and go to state 3

state 3

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 4

    (4) class_decl -> CLASS . ID found_class_name extends_class LCURLY class_body_decl RCURLY

    ID              shift and go to state 6


state 5

    (1) program -> class_decl program .

    $end            reduce using rule 1 (program -> class_decl program .)


state 6

    (4) class_decl -> CLASS ID . found_class_name extends_class LCURLY class_body_decl RCURLY
    (5) found_class_name -> .

    EXTENDS         reduce using rule 5 (found_class_name -> .)
    LCURLY          reduce using rule 5 (found_class_name -> .)

    found_class_name               shift and go to state 7

state 7

    (4) class_decl -> CLASS ID found_class_name . extends_class LCURLY class_body_decl RCURLY
    (6) extends_class -> . EXTENDS ID
    (7) extends_class -> . empty
    (3) empty -> .

    EXTENDS         shift and go to state 9
    LCURLY          reduce using rule 3 (empty -> .)

    extends_class                  shift and go to state 8
    empty                          shift and go to state 10

state 8

    (4) class_decl -> CLASS ID found_class_name extends_class . LCURLY class_body_decl RCURLY

    LCURLY          shift and go to state 11


state 9

    (6) extends_class -> EXTENDS . ID

    ID              shift and go to state 12


state 10

    (7) extends_class -> empty .

    LCURLY          reduce using rule 7 (extends_class -> empty .)


state 11

    (4) class_decl -> CLASS ID found_class_name extends_class LCURLY . class_body_decl RCURLY
    (8) class_body_decl -> . class_body_decl_type class_body_decl
    (9) class_body_decl -> . class_body_decl_type
    (10) class_body_decl_type -> . field_decl
    (11) class_body_decl_type -> . method_decl
    (12) class_body_decl_type -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (31) method_decl -> . modifier type ID found_method_type LPAREN formals RPAREN block
    (33) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (14) modifier -> . visibility optional_static
    (15) visibility -> . PUBLIC
    (16) visibility -> . PRIVATE
    (17) visibility -> . empty
    (3) empty -> .

    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 21
    STATIC          reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)
    VOID            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)

    class_body_decl                shift and go to state 13
    class_body_decl_type           shift and go to state 14
    field_decl                     shift and go to state 15
    method_decl                    shift and go to state 16
    constructor_decl               shift and go to state 17
    modifier                       shift and go to state 18
    visibility                     shift and go to state 19
    empty                          shift and go to state 22

state 12

    (6) extends_class -> EXTENDS ID .

    LCURLY          reduce using rule 6 (extends_class -> EXTENDS ID .)


state 13

    (4) class_decl -> CLASS ID found_class_name extends_class LCURLY class_body_decl . RCURLY

    RCURLY          shift and go to state 23


state 14

    (8) class_body_decl -> class_body_decl_type . class_body_decl
    (9) class_body_decl -> class_body_decl_type .
    (8) class_body_decl -> . class_body_decl_type class_body_decl
    (9) class_body_decl -> . class_body_decl_type
    (10) class_body_decl_type -> . field_decl
    (11) class_body_decl_type -> . method_decl
    (12) class_body_decl_type -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (31) method_decl -> . modifier type ID found_method_type LPAREN formals RPAREN block
    (33) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (14) modifier -> . visibility optional_static
    (15) visibility -> . PUBLIC
    (16) visibility -> . PRIVATE
    (17) visibility -> . empty
    (3) empty -> .

    RCURLY          reduce using rule 9 (class_body_decl -> class_body_decl_type .)
    PUBLIC          shift and go to state 20
    PRIVATE         shift and go to state 21
    STATIC          reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)
    VOID            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)

    class_body_decl_type           shift and go to state 14
    class_body_decl                shift and go to state 24
    field_decl                     shift and go to state 15
    method_decl                    shift and go to state 16
    constructor_decl               shift and go to state 17
    modifier                       shift and go to state 18
    visibility                     shift and go to state 19
    empty                          shift and go to state 22

state 15

    (10) class_body_decl_type -> field_decl .

    PUBLIC          reduce using rule 10 (class_body_decl_type -> field_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl_type -> field_decl .)
    ID              reduce using rule 10 (class_body_decl_type -> field_decl .)
    INT             reduce using rule 10 (class_body_decl_type -> field_decl .)
    FLOAT           reduce using rule 10 (class_body_decl_type -> field_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl_type -> field_decl .)
    VOID            reduce using rule 10 (class_body_decl_type -> field_decl .)
    NULL            reduce using rule 10 (class_body_decl_type -> field_decl .)
    STATIC          reduce using rule 10 (class_body_decl_type -> field_decl .)
    RCURLY          reduce using rule 10 (class_body_decl_type -> field_decl .)


state 16

    (11) class_body_decl_type -> method_decl .

    PUBLIC          reduce using rule 11 (class_body_decl_type -> method_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl_type -> method_decl .)
    ID              reduce using rule 11 (class_body_decl_type -> method_decl .)
    INT             reduce using rule 11 (class_body_decl_type -> method_decl .)
    FLOAT           reduce using rule 11 (class_body_decl_type -> method_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl_type -> method_decl .)
    VOID            reduce using rule 11 (class_body_decl_type -> method_decl .)
    NULL            reduce using rule 11 (class_body_decl_type -> method_decl .)
    STATIC          reduce using rule 11 (class_body_decl_type -> method_decl .)
    RCURLY          reduce using rule 11 (class_body_decl_type -> method_decl .)


state 17

    (12) class_body_decl_type -> constructor_decl .

    PUBLIC          reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    PRIVATE         reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    ID              reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    INT             reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    FLOAT           reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    BOOLEAN         reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    VOID            reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    NULL            reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    STATIC          reduce using rule 12 (class_body_decl_type -> constructor_decl .)
    RCURLY          reduce using rule 12 (class_body_decl_type -> constructor_decl .)


state 18

    (13) field_decl -> modifier . var_decl
    (31) method_decl -> modifier . type ID found_method_type LPAREN formals RPAREN block
    (33) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (20) var_decl -> . type variables SEMICOLON
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID

    ID              shift and go to state 27
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 32

    var_decl                       shift and go to state 25
    type                           shift and go to state 26

state 19

    (14) modifier -> visibility . optional_static
    (18) optional_static -> . STATIC
    (19) optional_static -> . empty
    (3) empty -> .

    STATIC          shift and go to state 34
    ID              reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)
    VOID            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)

    optional_static                shift and go to state 33
    empty                          shift and go to state 35

state 20

    (15) visibility -> PUBLIC .

    STATIC          reduce using rule 15 (visibility -> PUBLIC .)
    ID              reduce using rule 15 (visibility -> PUBLIC .)
    INT             reduce using rule 15 (visibility -> PUBLIC .)
    FLOAT           reduce using rule 15 (visibility -> PUBLIC .)
    BOOLEAN         reduce using rule 15 (visibility -> PUBLIC .)
    VOID            reduce using rule 15 (visibility -> PUBLIC .)
    NULL            reduce using rule 15 (visibility -> PUBLIC .)


state 21

    (16) visibility -> PRIVATE .

    STATIC          reduce using rule 16 (visibility -> PRIVATE .)
    ID              reduce using rule 16 (visibility -> PRIVATE .)
    INT             reduce using rule 16 (visibility -> PRIVATE .)
    FLOAT           reduce using rule 16 (visibility -> PRIVATE .)
    BOOLEAN         reduce using rule 16 (visibility -> PRIVATE .)
    VOID            reduce using rule 16 (visibility -> PRIVATE .)
    NULL            reduce using rule 16 (visibility -> PRIVATE .)


state 22

    (17) visibility -> empty .

    STATIC          reduce using rule 17 (visibility -> empty .)
    ID              reduce using rule 17 (visibility -> empty .)
    INT             reduce using rule 17 (visibility -> empty .)
    FLOAT           reduce using rule 17 (visibility -> empty .)
    BOOLEAN         reduce using rule 17 (visibility -> empty .)
    VOID            reduce using rule 17 (visibility -> empty .)
    NULL            reduce using rule 17 (visibility -> empty .)


state 23

    (4) class_decl -> CLASS ID found_class_name extends_class LCURLY class_body_decl RCURLY .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID found_class_name extends_class LCURLY class_body_decl RCURLY .)
    $end            reduce using rule 4 (class_decl -> CLASS ID found_class_name extends_class LCURLY class_body_decl RCURLY .)


state 24

    (8) class_body_decl -> class_body_decl_type class_body_decl .

    RCURLY          reduce using rule 8 (class_body_decl -> class_body_decl_type class_body_decl .)


state 25

    (13) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 13 (field_decl -> modifier var_decl .)
    ID              reduce using rule 13 (field_decl -> modifier var_decl .)
    INT             reduce using rule 13 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 13 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 13 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 13 (field_decl -> modifier var_decl .)
    NULL            reduce using rule 13 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    RCURLY          reduce using rule 13 (field_decl -> modifier var_decl .)


state 26

    (31) method_decl -> modifier type . ID found_method_type LPAREN formals RPAREN block
    (20) var_decl -> type . variables SEMICOLON
    (27) variables -> . variable additional_vars
    (28) variable -> . ID

    ID              shift and go to state 36

    variables                      shift and go to state 37
    variable                       shift and go to state 38

state 27

    (33) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (26) type -> ID .

    LPAREN          shift and go to state 39
    ID              reduce using rule 26 (type -> ID .)


state 28

    (21) type -> INT .

    ID              reduce using rule 21 (type -> INT .)


state 29

    (22) type -> FLOAT .

    ID              reduce using rule 22 (type -> FLOAT .)


state 30

    (23) type -> BOOLEAN .

    ID              reduce using rule 23 (type -> BOOLEAN .)


state 31

    (24) type -> VOID .

    ID              reduce using rule 24 (type -> VOID .)


state 32

    (25) type -> NULL .

    ID              reduce using rule 25 (type -> NULL .)


state 33

    (14) modifier -> visibility optional_static .

    ID              reduce using rule 14 (modifier -> visibility optional_static .)
    INT             reduce using rule 14 (modifier -> visibility optional_static .)
    FLOAT           reduce using rule 14 (modifier -> visibility optional_static .)
    BOOLEAN         reduce using rule 14 (modifier -> visibility optional_static .)
    VOID            reduce using rule 14 (modifier -> visibility optional_static .)
    NULL            reduce using rule 14 (modifier -> visibility optional_static .)


state 34

    (18) optional_static -> STATIC .

    ID              reduce using rule 18 (optional_static -> STATIC .)
    INT             reduce using rule 18 (optional_static -> STATIC .)
    FLOAT           reduce using rule 18 (optional_static -> STATIC .)
    BOOLEAN         reduce using rule 18 (optional_static -> STATIC .)
    VOID            reduce using rule 18 (optional_static -> STATIC .)
    NULL            reduce using rule 18 (optional_static -> STATIC .)


state 35

    (19) optional_static -> empty .

    ID              reduce using rule 19 (optional_static -> empty .)
    INT             reduce using rule 19 (optional_static -> empty .)
    FLOAT           reduce using rule 19 (optional_static -> empty .)
    BOOLEAN         reduce using rule 19 (optional_static -> empty .)
    VOID            reduce using rule 19 (optional_static -> empty .)
    NULL            reduce using rule 19 (optional_static -> empty .)


state 36

    (31) method_decl -> modifier type ID . found_method_type LPAREN formals RPAREN block
    (28) variable -> ID .
    (32) found_method_type -> .

    COMMA           reduce using rule 28 (variable -> ID .)
    SEMICOLON       reduce using rule 28 (variable -> ID .)
    LPAREN          reduce using rule 32 (found_method_type -> .)

    found_method_type              shift and go to state 40

state 37

    (20) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 41


state 38

    (27) variables -> variable . additional_vars
    (29) additional_vars -> . COMMA variable additional_vars
    (30) additional_vars -> . empty
    (3) empty -> .

    COMMA           shift and go to state 43
    SEMICOLON       reduce using rule 3 (empty -> .)

    additional_vars                shift and go to state 42
    empty                          shift and go to state 44

state 39

    (33) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (34) formals -> . formal_param additional_formal_params
    (35) formals -> . empty
    (36) formal_param -> . type variable
    (3) empty -> .
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID

    RPAREN          reduce using rule 3 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 32
    ID              shift and go to state 45

    formals                        shift and go to state 46
    formal_param                   shift and go to state 47
    empty                          shift and go to state 48
    type                           shift and go to state 49

state 40

    (31) method_decl -> modifier type ID found_method_type . LPAREN formals RPAREN block

    LPAREN          shift and go to state 50


state 41

    (20) var_decl -> type variables SEMICOLON .

    PUBLIC          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    RCURLY          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INCREMENT       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    DECREMENT       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    STRING          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 20 (var_decl -> type variables SEMICOLON .)


state 42

    (27) variables -> variable additional_vars .

    SEMICOLON       reduce using rule 27 (variables -> variable additional_vars .)


state 43

    (29) additional_vars -> COMMA . variable additional_vars
    (28) variable -> . ID

    ID              shift and go to state 52

    variable                       shift and go to state 51

state 44

    (30) additional_vars -> empty .

    SEMICOLON       reduce using rule 30 (additional_vars -> empty .)


state 45

    (26) type -> ID .

    ID              reduce using rule 26 (type -> ID .)


state 46

    (33) constructor_decl -> modifier ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 53


state 47

    (34) formals -> formal_param . additional_formal_params
    (37) additional_formal_params -> . COMMA formal_param additional_formal_params
    (38) additional_formal_params -> . empty
    (3) empty -> .

    COMMA           shift and go to state 55
    RPAREN          reduce using rule 3 (empty -> .)

    additional_formal_params       shift and go to state 54
    empty                          shift and go to state 56

state 48

    (35) formals -> empty .

    RPAREN          reduce using rule 35 (formals -> empty .)


state 49

    (36) formal_param -> type . variable
    (28) variable -> . ID

    ID              shift and go to state 52

    variable                       shift and go to state 57

state 50

    (31) method_decl -> modifier type ID found_method_type LPAREN . formals RPAREN block
    (34) formals -> . formal_param additional_formal_params
    (35) formals -> . empty
    (36) formal_param -> . type variable
    (3) empty -> .
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID

    RPAREN          reduce using rule 3 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 32
    ID              shift and go to state 45

    type                           shift and go to state 49
    formals                        shift and go to state 58
    formal_param                   shift and go to state 47
    empty                          shift and go to state 48

state 51

    (29) additional_vars -> COMMA variable . additional_vars
    (29) additional_vars -> . COMMA variable additional_vars
    (30) additional_vars -> . empty
    (3) empty -> .

    COMMA           shift and go to state 43
    SEMICOLON       reduce using rule 3 (empty -> .)

    additional_vars                shift and go to state 59
    empty                          shift and go to state 44

state 52

    (28) variable -> ID .

    COMMA           reduce using rule 28 (variable -> ID .)
    SEMICOLON       reduce using rule 28 (variable -> ID .)
    RPAREN          reduce using rule 28 (variable -> ID .)


state 53

    (33) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (39) block -> . LCURLY new_scope stmt_section RCURLY

    LCURLY          shift and go to state 61

    block                          shift and go to state 60

state 54

    (34) formals -> formal_param additional_formal_params .

    RPAREN          reduce using rule 34 (formals -> formal_param additional_formal_params .)


state 55

    (37) additional_formal_params -> COMMA . formal_param additional_formal_params
    (36) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 32
    ID              shift and go to state 45

    formal_param                   shift and go to state 62
    type                           shift and go to state 49

state 56

    (38) additional_formal_params -> empty .

    RPAREN          reduce using rule 38 (additional_formal_params -> empty .)


state 57

    (36) formal_param -> type variable .

    COMMA           reduce using rule 36 (formal_param -> type variable .)
    RPAREN          reduce using rule 36 (formal_param -> type variable .)


state 58

    (31) method_decl -> modifier type ID found_method_type LPAREN formals . RPAREN block

    RPAREN          shift and go to state 63


state 59

    (29) additional_vars -> COMMA variable additional_vars .

    SEMICOLON       reduce using rule 29 (additional_vars -> COMMA variable additional_vars .)


state 60

    (33) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    NULL            reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 33 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 61

    (39) block -> LCURLY . new_scope stmt_section RCURLY
    (40) new_scope -> .

    BREAK           reduce using rule 40 (new_scope -> .)
    CONTINUE        reduce using rule 40 (new_scope -> .)
    SEMICOLON       reduce using rule 40 (new_scope -> .)
    IF              reduce using rule 40 (new_scope -> .)
    WHILE           reduce using rule 40 (new_scope -> .)
    FOR             reduce using rule 40 (new_scope -> .)
    RETURN          reduce using rule 40 (new_scope -> .)
    LCURLY          reduce using rule 40 (new_scope -> .)
    INCREMENT       reduce using rule 40 (new_scope -> .)
    DECREMENT       reduce using rule 40 (new_scope -> .)
    INT             reduce using rule 40 (new_scope -> .)
    FLOAT           reduce using rule 40 (new_scope -> .)
    BOOLEAN         reduce using rule 40 (new_scope -> .)
    VOID            reduce using rule 40 (new_scope -> .)
    NULL            reduce using rule 40 (new_scope -> .)
    ID              reduce using rule 40 (new_scope -> .)
    THIS            reduce using rule 40 (new_scope -> .)
    SUPER           reduce using rule 40 (new_scope -> .)
    LPAREN          reduce using rule 40 (new_scope -> .)
    INT_CONST       reduce using rule 40 (new_scope -> .)
    FLOAT_CONST     reduce using rule 40 (new_scope -> .)
    STRING          reduce using rule 40 (new_scope -> .)
    TRUE            reduce using rule 40 (new_scope -> .)
    FALSE           reduce using rule 40 (new_scope -> .)
    NEW             reduce using rule 40 (new_scope -> .)
    RCURLY          reduce using rule 40 (new_scope -> .)

    new_scope                      shift and go to state 64

state 62

    (37) additional_formal_params -> COMMA formal_param . additional_formal_params
    (37) additional_formal_params -> . COMMA formal_param additional_formal_params
    (38) additional_formal_params -> . empty
    (3) empty -> .

    COMMA           shift and go to state 55
    RPAREN          reduce using rule 3 (empty -> .)

    additional_formal_params       shift and go to state 65
    empty                          shift and go to state 56

state 63

    (31) method_decl -> modifier type ID found_method_type LPAREN formals RPAREN . block
    (39) block -> . LCURLY new_scope stmt_section RCURLY

    LCURLY          shift and go to state 61

    block                          shift and go to state 66

state 64

    (39) block -> LCURLY new_scope . stmt_section RCURLY
    (41) stmt_section -> . stmt stmt_section
    (42) stmt_section -> . empty
    (43) stmt -> . if_stmt
    (44) stmt -> . while_stmt
    (45) stmt -> . for_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (3) empty -> .
    (53) if_stmt -> . IF LPAREN expr RPAREN stmt else_stmt
    (56) while_stmt -> . WHILE LPAREN expr RPAREN stmt
    (57) for_stmt -> . FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (58) return_stmt -> . RETURN optional_expr SEMICOLON
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (39) block -> . LCURLY new_scope stmt_section RCURLY
    (20) var_decl -> . type variables SEMICOLON
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 75
    RCURLY          reduce using rule 3 (empty -> .)
    IF              shift and go to state 80
    WHILE           shift and go to state 82
    FOR             shift and go to state 83
    RETURN          shift and go to state 84
    LCURLY          shift and go to state 61
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 93
    ID              shift and go to state 92
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    stmt_section                   shift and go to state 67
    stmt                           shift and go to state 68
    empty                          shift and go to state 69
    if_stmt                        shift and go to state 70
    while_stmt                     shift and go to state 71
    for_stmt                       shift and go to state 72
    return_stmt                    shift and go to state 73
    stmt_expr                      shift and go to state 74
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    type                           shift and go to state 87
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 65

    (37) additional_formal_params -> COMMA formal_param additional_formal_params .

    RPAREN          reduce using rule 37 (additional_formal_params -> COMMA formal_param additional_formal_params .)


state 66

    (31) method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    ID              reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    INT             reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    VOID            reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    NULL            reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    STATIC          reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 31 (method_decl -> modifier type ID found_method_type LPAREN formals RPAREN block .)


state 67

    (39) block -> LCURLY new_scope stmt_section . RCURLY

    RCURLY          shift and go to state 105


state 68

    (41) stmt_section -> stmt . stmt_section
    (41) stmt_section -> . stmt stmt_section
    (42) stmt_section -> . empty
    (43) stmt -> . if_stmt
    (44) stmt -> . while_stmt
    (45) stmt -> . for_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (3) empty -> .
    (53) if_stmt -> . IF LPAREN expr RPAREN stmt else_stmt
    (56) while_stmt -> . WHILE LPAREN expr RPAREN stmt
    (57) for_stmt -> . FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (58) return_stmt -> . RETURN optional_expr SEMICOLON
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (39) block -> . LCURLY new_scope stmt_section RCURLY
    (20) var_decl -> . type variables SEMICOLON
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 75
    RCURLY          reduce using rule 3 (empty -> .)
    IF              shift and go to state 80
    WHILE           shift and go to state 82
    FOR             shift and go to state 83
    RETURN          shift and go to state 84
    LCURLY          shift and go to state 61
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 93
    ID              shift and go to state 92
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    stmt                           shift and go to state 68
    stmt_section                   shift and go to state 106
    empty                          shift and go to state 69
    if_stmt                        shift and go to state 70
    while_stmt                     shift and go to state 71
    for_stmt                       shift and go to state 72
    return_stmt                    shift and go to state 73
    stmt_expr                      shift and go to state 74
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    type                           shift and go to state 87
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 69

    (42) stmt_section -> empty .

    RCURLY          reduce using rule 42 (stmt_section -> empty .)


state 70

    (43) stmt -> if_stmt .

    BREAK           reduce using rule 43 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> if_stmt .)
    SEMICOLON       reduce using rule 43 (stmt -> if_stmt .)
    IF              reduce using rule 43 (stmt -> if_stmt .)
    WHILE           reduce using rule 43 (stmt -> if_stmt .)
    FOR             reduce using rule 43 (stmt -> if_stmt .)
    RETURN          reduce using rule 43 (stmt -> if_stmt .)
    LCURLY          reduce using rule 43 (stmt -> if_stmt .)
    INCREMENT       reduce using rule 43 (stmt -> if_stmt .)
    DECREMENT       reduce using rule 43 (stmt -> if_stmt .)
    INT             reduce using rule 43 (stmt -> if_stmt .)
    FLOAT           reduce using rule 43 (stmt -> if_stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> if_stmt .)
    VOID            reduce using rule 43 (stmt -> if_stmt .)
    NULL            reduce using rule 43 (stmt -> if_stmt .)
    ID              reduce using rule 43 (stmt -> if_stmt .)
    THIS            reduce using rule 43 (stmt -> if_stmt .)
    SUPER           reduce using rule 43 (stmt -> if_stmt .)
    LPAREN          reduce using rule 43 (stmt -> if_stmt .)
    INT_CONST       reduce using rule 43 (stmt -> if_stmt .)
    FLOAT_CONST     reduce using rule 43 (stmt -> if_stmt .)
    STRING          reduce using rule 43 (stmt -> if_stmt .)
    TRUE            reduce using rule 43 (stmt -> if_stmt .)
    FALSE           reduce using rule 43 (stmt -> if_stmt .)
    NEW             reduce using rule 43 (stmt -> if_stmt .)
    RCURLY          reduce using rule 43 (stmt -> if_stmt .)
    ELSE            reduce using rule 43 (stmt -> if_stmt .)


state 71

    (44) stmt -> while_stmt .

    BREAK           reduce using rule 44 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 44 (stmt -> while_stmt .)
    SEMICOLON       reduce using rule 44 (stmt -> while_stmt .)
    IF              reduce using rule 44 (stmt -> while_stmt .)
    WHILE           reduce using rule 44 (stmt -> while_stmt .)
    FOR             reduce using rule 44 (stmt -> while_stmt .)
    RETURN          reduce using rule 44 (stmt -> while_stmt .)
    LCURLY          reduce using rule 44 (stmt -> while_stmt .)
    INCREMENT       reduce using rule 44 (stmt -> while_stmt .)
    DECREMENT       reduce using rule 44 (stmt -> while_stmt .)
    INT             reduce using rule 44 (stmt -> while_stmt .)
    FLOAT           reduce using rule 44 (stmt -> while_stmt .)
    BOOLEAN         reduce using rule 44 (stmt -> while_stmt .)
    VOID            reduce using rule 44 (stmt -> while_stmt .)
    NULL            reduce using rule 44 (stmt -> while_stmt .)
    ID              reduce using rule 44 (stmt -> while_stmt .)
    THIS            reduce using rule 44 (stmt -> while_stmt .)
    SUPER           reduce using rule 44 (stmt -> while_stmt .)
    LPAREN          reduce using rule 44 (stmt -> while_stmt .)
    INT_CONST       reduce using rule 44 (stmt -> while_stmt .)
    FLOAT_CONST     reduce using rule 44 (stmt -> while_stmt .)
    STRING          reduce using rule 44 (stmt -> while_stmt .)
    TRUE            reduce using rule 44 (stmt -> while_stmt .)
    FALSE           reduce using rule 44 (stmt -> while_stmt .)
    NEW             reduce using rule 44 (stmt -> while_stmt .)
    RCURLY          reduce using rule 44 (stmt -> while_stmt .)
    ELSE            reduce using rule 44 (stmt -> while_stmt .)


state 72

    (45) stmt -> for_stmt .

    BREAK           reduce using rule 45 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 45 (stmt -> for_stmt .)
    SEMICOLON       reduce using rule 45 (stmt -> for_stmt .)
    IF              reduce using rule 45 (stmt -> for_stmt .)
    WHILE           reduce using rule 45 (stmt -> for_stmt .)
    FOR             reduce using rule 45 (stmt -> for_stmt .)
    RETURN          reduce using rule 45 (stmt -> for_stmt .)
    LCURLY          reduce using rule 45 (stmt -> for_stmt .)
    INCREMENT       reduce using rule 45 (stmt -> for_stmt .)
    DECREMENT       reduce using rule 45 (stmt -> for_stmt .)
    INT             reduce using rule 45 (stmt -> for_stmt .)
    FLOAT           reduce using rule 45 (stmt -> for_stmt .)
    BOOLEAN         reduce using rule 45 (stmt -> for_stmt .)
    VOID            reduce using rule 45 (stmt -> for_stmt .)
    NULL            reduce using rule 45 (stmt -> for_stmt .)
    ID              reduce using rule 45 (stmt -> for_stmt .)
    THIS            reduce using rule 45 (stmt -> for_stmt .)
    SUPER           reduce using rule 45 (stmt -> for_stmt .)
    LPAREN          reduce using rule 45 (stmt -> for_stmt .)
    INT_CONST       reduce using rule 45 (stmt -> for_stmt .)
    FLOAT_CONST     reduce using rule 45 (stmt -> for_stmt .)
    STRING          reduce using rule 45 (stmt -> for_stmt .)
    TRUE            reduce using rule 45 (stmt -> for_stmt .)
    FALSE           reduce using rule 45 (stmt -> for_stmt .)
    NEW             reduce using rule 45 (stmt -> for_stmt .)
    RCURLY          reduce using rule 45 (stmt -> for_stmt .)
    ELSE            reduce using rule 45 (stmt -> for_stmt .)


state 73

    (46) stmt -> return_stmt .

    BREAK           reduce using rule 46 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 46 (stmt -> return_stmt .)
    SEMICOLON       reduce using rule 46 (stmt -> return_stmt .)
    IF              reduce using rule 46 (stmt -> return_stmt .)
    WHILE           reduce using rule 46 (stmt -> return_stmt .)
    FOR             reduce using rule 46 (stmt -> return_stmt .)
    RETURN          reduce using rule 46 (stmt -> return_stmt .)
    LCURLY          reduce using rule 46 (stmt -> return_stmt .)
    INCREMENT       reduce using rule 46 (stmt -> return_stmt .)
    DECREMENT       reduce using rule 46 (stmt -> return_stmt .)
    INT             reduce using rule 46 (stmt -> return_stmt .)
    FLOAT           reduce using rule 46 (stmt -> return_stmt .)
    BOOLEAN         reduce using rule 46 (stmt -> return_stmt .)
    VOID            reduce using rule 46 (stmt -> return_stmt .)
    NULL            reduce using rule 46 (stmt -> return_stmt .)
    ID              reduce using rule 46 (stmt -> return_stmt .)
    THIS            reduce using rule 46 (stmt -> return_stmt .)
    SUPER           reduce using rule 46 (stmt -> return_stmt .)
    LPAREN          reduce using rule 46 (stmt -> return_stmt .)
    INT_CONST       reduce using rule 46 (stmt -> return_stmt .)
    FLOAT_CONST     reduce using rule 46 (stmt -> return_stmt .)
    STRING          reduce using rule 46 (stmt -> return_stmt .)
    TRUE            reduce using rule 46 (stmt -> return_stmt .)
    FALSE           reduce using rule 46 (stmt -> return_stmt .)
    NEW             reduce using rule 46 (stmt -> return_stmt .)
    RCURLY          reduce using rule 46 (stmt -> return_stmt .)
    ELSE            reduce using rule 46 (stmt -> return_stmt .)


state 74

    (47) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 107


state 75

    (52) stmt -> SEMICOLON .

    BREAK           reduce using rule 52 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 52 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stmt -> SEMICOLON .)
    IF              reduce using rule 52 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 52 (stmt -> SEMICOLON .)
    FOR             reduce using rule 52 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 52 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 52 (stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 52 (stmt -> SEMICOLON .)
    DECREMENT       reduce using rule 52 (stmt -> SEMICOLON .)
    INT             reduce using rule 52 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 52 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 52 (stmt -> SEMICOLON .)
    VOID            reduce using rule 52 (stmt -> SEMICOLON .)
    NULL            reduce using rule 52 (stmt -> SEMICOLON .)
    ID              reduce using rule 52 (stmt -> SEMICOLON .)
    THIS            reduce using rule 52 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 52 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 52 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 52 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 52 (stmt -> SEMICOLON .)
    STRING          reduce using rule 52 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 52 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 52 (stmt -> SEMICOLON .)
    NEW             reduce using rule 52 (stmt -> SEMICOLON .)
    RCURLY          reduce using rule 52 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 52 (stmt -> SEMICOLON .)


state 76

    (48) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 108


state 77

    (49) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 109


state 78

    (50) stmt -> block .

    BREAK           reduce using rule 50 (stmt -> block .)
    CONTINUE        reduce using rule 50 (stmt -> block .)
    SEMICOLON       reduce using rule 50 (stmt -> block .)
    IF              reduce using rule 50 (stmt -> block .)
    WHILE           reduce using rule 50 (stmt -> block .)
    FOR             reduce using rule 50 (stmt -> block .)
    RETURN          reduce using rule 50 (stmt -> block .)
    LCURLY          reduce using rule 50 (stmt -> block .)
    INCREMENT       reduce using rule 50 (stmt -> block .)
    DECREMENT       reduce using rule 50 (stmt -> block .)
    INT             reduce using rule 50 (stmt -> block .)
    FLOAT           reduce using rule 50 (stmt -> block .)
    BOOLEAN         reduce using rule 50 (stmt -> block .)
    VOID            reduce using rule 50 (stmt -> block .)
    NULL            reduce using rule 50 (stmt -> block .)
    ID              reduce using rule 50 (stmt -> block .)
    THIS            reduce using rule 50 (stmt -> block .)
    SUPER           reduce using rule 50 (stmt -> block .)
    LPAREN          reduce using rule 50 (stmt -> block .)
    INT_CONST       reduce using rule 50 (stmt -> block .)
    FLOAT_CONST     reduce using rule 50 (stmt -> block .)
    STRING          reduce using rule 50 (stmt -> block .)
    TRUE            reduce using rule 50 (stmt -> block .)
    FALSE           reduce using rule 50 (stmt -> block .)
    NEW             reduce using rule 50 (stmt -> block .)
    RCURLY          reduce using rule 50 (stmt -> block .)
    ELSE            reduce using rule 50 (stmt -> block .)


state 79

    (51) stmt -> var_decl .

    BREAK           reduce using rule 51 (stmt -> var_decl .)
    CONTINUE        reduce using rule 51 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 51 (stmt -> var_decl .)
    IF              reduce using rule 51 (stmt -> var_decl .)
    WHILE           reduce using rule 51 (stmt -> var_decl .)
    FOR             reduce using rule 51 (stmt -> var_decl .)
    RETURN          reduce using rule 51 (stmt -> var_decl .)
    LCURLY          reduce using rule 51 (stmt -> var_decl .)
    INCREMENT       reduce using rule 51 (stmt -> var_decl .)
    DECREMENT       reduce using rule 51 (stmt -> var_decl .)
    INT             reduce using rule 51 (stmt -> var_decl .)
    FLOAT           reduce using rule 51 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 51 (stmt -> var_decl .)
    VOID            reduce using rule 51 (stmt -> var_decl .)
    NULL            reduce using rule 51 (stmt -> var_decl .)
    ID              reduce using rule 51 (stmt -> var_decl .)
    THIS            reduce using rule 51 (stmt -> var_decl .)
    SUPER           reduce using rule 51 (stmt -> var_decl .)
    LPAREN          reduce using rule 51 (stmt -> var_decl .)
    INT_CONST       reduce using rule 51 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 51 (stmt -> var_decl .)
    STRING          reduce using rule 51 (stmt -> var_decl .)
    TRUE            reduce using rule 51 (stmt -> var_decl .)
    FALSE           reduce using rule 51 (stmt -> var_decl .)
    NEW             reduce using rule 51 (stmt -> var_decl .)
    RCURLY          reduce using rule 51 (stmt -> var_decl .)
    ELSE            reduce using rule 51 (stmt -> var_decl .)


state 80

    (53) if_stmt -> IF . LPAREN expr RPAREN stmt else_stmt

    LPAREN          shift and go to state 110


state 81

    (73) primary_expr -> LPAREN . expr RPAREN
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 111
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 82

    (56) while_stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 124


state 83

    (57) for_stmt -> FOR . LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt

    LPAREN          shift and go to state 125


state 84

    (58) return_stmt -> RETURN . optional_expr SEMICOLON
    (61) optional_expr -> . expr
    (62) optional_expr -> . empty
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (3) empty -> .
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    SEMICOLON       reduce using rule 3 (empty -> .)
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    optional_expr                  shift and go to state 126
    expr                           shift and go to state 127
    empty                          shift and go to state 128
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 85

    (63) stmt_expr -> assign_expr .

    SEMICOLON       reduce using rule 63 (stmt_expr -> assign_expr .)
    RPAREN          reduce using rule 63 (stmt_expr -> assign_expr .)


state 86

    (64) stmt_expr -> method_invocation .
    (76) primary_expr -> method_invocation .

    SEMICOLON       reduce using rule 64 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 64 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 76 (primary_expr -> method_invocation .)


state 87

    (20) var_decl -> type . variables SEMICOLON
    (27) variables -> . variable additional_vars
    (28) variable -> . ID

    ID              shift and go to state 52

    variables                      shift and go to state 37
    variable                       shift and go to state 38

state 88

    (92) assign_expr -> left_hand_side . ASSIGN_OP expr
    (93) assign_expr -> left_hand_side . INCREMENT
    (95) assign_expr -> left_hand_side . DECREMENT
    (75) primary_expr -> left_hand_side .

    ASSIGN_OP       shift and go to state 129
    INCREMENT       shift and go to state 130
    DECREMENT       shift and go to state 131
    DOT             reduce using rule 75 (primary_expr -> left_hand_side .)


state 89

    (94) assign_expr -> INCREMENT . left_hand_side
    (84) left_hand_side -> . field_access
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN

    ID              shift and go to state 123
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    left_hand_side                 shift and go to state 132
    field_access                   shift and go to state 94
    primary_expr                   shift and go to state 133
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    method_invocation              shift and go to state 118

state 90

    (96) assign_expr -> DECREMENT . left_hand_side
    (84) left_hand_side -> . field_access
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN

    ID              shift and go to state 123
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    left_hand_side                 shift and go to state 134
    field_access                   shift and go to state 94
    primary_expr                   shift and go to state 133
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    method_invocation              shift and go to state 118

state 91

    (87) method_invocation -> primary_expr . DOT ID LPAREN arguments RPAREN
    (85) field_access -> primary_expr . DOT ID

    DOT             shift and go to state 135


state 92

    (26) type -> ID .
    (86) field_access -> ID .

    ID              reduce using rule 26 (type -> ID .)
    ASSIGN_OP       reduce using rule 86 (field_access -> ID .)
    INCREMENT       reduce using rule 86 (field_access -> ID .)
    DECREMENT       reduce using rule 86 (field_access -> ID .)
    DOT             reduce using rule 86 (field_access -> ID .)


state 93

    (25) type -> NULL .
    (80) literal -> NULL .

    ID              reduce using rule 25 (type -> NULL .)
    DOT             reduce using rule 80 (literal -> NULL .)


state 94

    (84) left_hand_side -> field_access .

    ASSIGN_OP       reduce using rule 84 (left_hand_side -> field_access .)
    INCREMENT       reduce using rule 84 (left_hand_side -> field_access .)
    DECREMENT       reduce using rule 84 (left_hand_side -> field_access .)
    DOT             reduce using rule 84 (left_hand_side -> field_access .)
    RPAREN          reduce using rule 84 (left_hand_side -> field_access .)
    PLUS            reduce using rule 84 (left_hand_side -> field_access .)
    MINUS           reduce using rule 84 (left_hand_side -> field_access .)
    MULTIPLY        reduce using rule 84 (left_hand_side -> field_access .)
    DIVIDE          reduce using rule 84 (left_hand_side -> field_access .)
    AND             reduce using rule 84 (left_hand_side -> field_access .)
    OR              reduce using rule 84 (left_hand_side -> field_access .)
    EQUAL_TO        reduce using rule 84 (left_hand_side -> field_access .)
    NOT_EQUAL_TO    reduce using rule 84 (left_hand_side -> field_access .)
    LESS_THAN       reduce using rule 84 (left_hand_side -> field_access .)
    GREATER_THAN    reduce using rule 84 (left_hand_side -> field_access .)
    LESS_OR_EQUAL_TO reduce using rule 84 (left_hand_side -> field_access .)
    GREATER_OR_EQUAL_TO reduce using rule 84 (left_hand_side -> field_access .)
    SEMICOLON       reduce using rule 84 (left_hand_side -> field_access .)
    COMMA           reduce using rule 84 (left_hand_side -> field_access .)


state 95

    (70) primary_expr -> literal .

    DOT             reduce using rule 70 (primary_expr -> literal .)
    RPAREN          reduce using rule 70 (primary_expr -> literal .)
    PLUS            reduce using rule 70 (primary_expr -> literal .)
    MINUS           reduce using rule 70 (primary_expr -> literal .)
    MULTIPLY        reduce using rule 70 (primary_expr -> literal .)
    DIVIDE          reduce using rule 70 (primary_expr -> literal .)
    AND             reduce using rule 70 (primary_expr -> literal .)
    OR              reduce using rule 70 (primary_expr -> literal .)
    EQUAL_TO        reduce using rule 70 (primary_expr -> literal .)
    NOT_EQUAL_TO    reduce using rule 70 (primary_expr -> literal .)
    LESS_THAN       reduce using rule 70 (primary_expr -> literal .)
    GREATER_THAN    reduce using rule 70 (primary_expr -> literal .)
    LESS_OR_EQUAL_TO reduce using rule 70 (primary_expr -> literal .)
    GREATER_OR_EQUAL_TO reduce using rule 70 (primary_expr -> literal .)
    SEMICOLON       reduce using rule 70 (primary_expr -> literal .)
    COMMA           reduce using rule 70 (primary_expr -> literal .)


state 96

    (71) primary_expr -> THIS .

    DOT             reduce using rule 71 (primary_expr -> THIS .)
    RPAREN          reduce using rule 71 (primary_expr -> THIS .)
    PLUS            reduce using rule 71 (primary_expr -> THIS .)
    MINUS           reduce using rule 71 (primary_expr -> THIS .)
    MULTIPLY        reduce using rule 71 (primary_expr -> THIS .)
    DIVIDE          reduce using rule 71 (primary_expr -> THIS .)
    AND             reduce using rule 71 (primary_expr -> THIS .)
    OR              reduce using rule 71 (primary_expr -> THIS .)
    EQUAL_TO        reduce using rule 71 (primary_expr -> THIS .)
    NOT_EQUAL_TO    reduce using rule 71 (primary_expr -> THIS .)
    LESS_THAN       reduce using rule 71 (primary_expr -> THIS .)
    GREATER_THAN    reduce using rule 71 (primary_expr -> THIS .)
    LESS_OR_EQUAL_TO reduce using rule 71 (primary_expr -> THIS .)
    GREATER_OR_EQUAL_TO reduce using rule 71 (primary_expr -> THIS .)
    SEMICOLON       reduce using rule 71 (primary_expr -> THIS .)
    COMMA           reduce using rule 71 (primary_expr -> THIS .)


state 97

    (72) primary_expr -> SUPER .

    DOT             reduce using rule 72 (primary_expr -> SUPER .)
    RPAREN          reduce using rule 72 (primary_expr -> SUPER .)
    PLUS            reduce using rule 72 (primary_expr -> SUPER .)
    MINUS           reduce using rule 72 (primary_expr -> SUPER .)
    MULTIPLY        reduce using rule 72 (primary_expr -> SUPER .)
    DIVIDE          reduce using rule 72 (primary_expr -> SUPER .)
    AND             reduce using rule 72 (primary_expr -> SUPER .)
    OR              reduce using rule 72 (primary_expr -> SUPER .)
    EQUAL_TO        reduce using rule 72 (primary_expr -> SUPER .)
    NOT_EQUAL_TO    reduce using rule 72 (primary_expr -> SUPER .)
    LESS_THAN       reduce using rule 72 (primary_expr -> SUPER .)
    GREATER_THAN    reduce using rule 72 (primary_expr -> SUPER .)
    LESS_OR_EQUAL_TO reduce using rule 72 (primary_expr -> SUPER .)
    GREATER_OR_EQUAL_TO reduce using rule 72 (primary_expr -> SUPER .)
    SEMICOLON       reduce using rule 72 (primary_expr -> SUPER .)
    COMMA           reduce using rule 72 (primary_expr -> SUPER .)


state 98

    (74) primary_expr -> new_object .

    DOT             reduce using rule 74 (primary_expr -> new_object .)
    RPAREN          reduce using rule 74 (primary_expr -> new_object .)
    PLUS            reduce using rule 74 (primary_expr -> new_object .)
    MINUS           reduce using rule 74 (primary_expr -> new_object .)
    MULTIPLY        reduce using rule 74 (primary_expr -> new_object .)
    DIVIDE          reduce using rule 74 (primary_expr -> new_object .)
    AND             reduce using rule 74 (primary_expr -> new_object .)
    OR              reduce using rule 74 (primary_expr -> new_object .)
    EQUAL_TO        reduce using rule 74 (primary_expr -> new_object .)
    NOT_EQUAL_TO    reduce using rule 74 (primary_expr -> new_object .)
    LESS_THAN       reduce using rule 74 (primary_expr -> new_object .)
    GREATER_THAN    reduce using rule 74 (primary_expr -> new_object .)
    LESS_OR_EQUAL_TO reduce using rule 74 (primary_expr -> new_object .)
    GREATER_OR_EQUAL_TO reduce using rule 74 (primary_expr -> new_object .)
    SEMICOLON       reduce using rule 74 (primary_expr -> new_object .)
    COMMA           reduce using rule 74 (primary_expr -> new_object .)


state 99

    (77) literal -> INT_CONST .

    DOT             reduce using rule 77 (literal -> INT_CONST .)
    RPAREN          reduce using rule 77 (literal -> INT_CONST .)
    PLUS            reduce using rule 77 (literal -> INT_CONST .)
    MINUS           reduce using rule 77 (literal -> INT_CONST .)
    MULTIPLY        reduce using rule 77 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 77 (literal -> INT_CONST .)
    AND             reduce using rule 77 (literal -> INT_CONST .)
    OR              reduce using rule 77 (literal -> INT_CONST .)
    EQUAL_TO        reduce using rule 77 (literal -> INT_CONST .)
    NOT_EQUAL_TO    reduce using rule 77 (literal -> INT_CONST .)
    LESS_THAN       reduce using rule 77 (literal -> INT_CONST .)
    GREATER_THAN    reduce using rule 77 (literal -> INT_CONST .)
    LESS_OR_EQUAL_TO reduce using rule 77 (literal -> INT_CONST .)
    GREATER_OR_EQUAL_TO reduce using rule 77 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 77 (literal -> INT_CONST .)
    COMMA           reduce using rule 77 (literal -> INT_CONST .)


state 100

    (78) literal -> FLOAT_CONST .

    DOT             reduce using rule 78 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 78 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 78 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 78 (literal -> FLOAT_CONST .)
    MULTIPLY        reduce using rule 78 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 78 (literal -> FLOAT_CONST .)
    AND             reduce using rule 78 (literal -> FLOAT_CONST .)
    OR              reduce using rule 78 (literal -> FLOAT_CONST .)
    EQUAL_TO        reduce using rule 78 (literal -> FLOAT_CONST .)
    NOT_EQUAL_TO    reduce using rule 78 (literal -> FLOAT_CONST .)
    LESS_THAN       reduce using rule 78 (literal -> FLOAT_CONST .)
    GREATER_THAN    reduce using rule 78 (literal -> FLOAT_CONST .)
    LESS_OR_EQUAL_TO reduce using rule 78 (literal -> FLOAT_CONST .)
    GREATER_OR_EQUAL_TO reduce using rule 78 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 78 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 78 (literal -> FLOAT_CONST .)


state 101

    (79) literal -> STRING .

    DOT             reduce using rule 79 (literal -> STRING .)
    RPAREN          reduce using rule 79 (literal -> STRING .)
    PLUS            reduce using rule 79 (literal -> STRING .)
    MINUS           reduce using rule 79 (literal -> STRING .)
    MULTIPLY        reduce using rule 79 (literal -> STRING .)
    DIVIDE          reduce using rule 79 (literal -> STRING .)
    AND             reduce using rule 79 (literal -> STRING .)
    OR              reduce using rule 79 (literal -> STRING .)
    EQUAL_TO        reduce using rule 79 (literal -> STRING .)
    NOT_EQUAL_TO    reduce using rule 79 (literal -> STRING .)
    LESS_THAN       reduce using rule 79 (literal -> STRING .)
    GREATER_THAN    reduce using rule 79 (literal -> STRING .)
    LESS_OR_EQUAL_TO reduce using rule 79 (literal -> STRING .)
    GREATER_OR_EQUAL_TO reduce using rule 79 (literal -> STRING .)
    SEMICOLON       reduce using rule 79 (literal -> STRING .)
    COMMA           reduce using rule 79 (literal -> STRING .)


state 102

    (81) literal -> TRUE .

    DOT             reduce using rule 81 (literal -> TRUE .)
    RPAREN          reduce using rule 81 (literal -> TRUE .)
    PLUS            reduce using rule 81 (literal -> TRUE .)
    MINUS           reduce using rule 81 (literal -> TRUE .)
    MULTIPLY        reduce using rule 81 (literal -> TRUE .)
    DIVIDE          reduce using rule 81 (literal -> TRUE .)
    AND             reduce using rule 81 (literal -> TRUE .)
    OR              reduce using rule 81 (literal -> TRUE .)
    EQUAL_TO        reduce using rule 81 (literal -> TRUE .)
    NOT_EQUAL_TO    reduce using rule 81 (literal -> TRUE .)
    LESS_THAN       reduce using rule 81 (literal -> TRUE .)
    GREATER_THAN    reduce using rule 81 (literal -> TRUE .)
    LESS_OR_EQUAL_TO reduce using rule 81 (literal -> TRUE .)
    GREATER_OR_EQUAL_TO reduce using rule 81 (literal -> TRUE .)
    SEMICOLON       reduce using rule 81 (literal -> TRUE .)
    COMMA           reduce using rule 81 (literal -> TRUE .)


state 103

    (82) literal -> FALSE .

    DOT             reduce using rule 82 (literal -> FALSE .)
    RPAREN          reduce using rule 82 (literal -> FALSE .)
    PLUS            reduce using rule 82 (literal -> FALSE .)
    MINUS           reduce using rule 82 (literal -> FALSE .)
    MULTIPLY        reduce using rule 82 (literal -> FALSE .)
    DIVIDE          reduce using rule 82 (literal -> FALSE .)
    AND             reduce using rule 82 (literal -> FALSE .)
    OR              reduce using rule 82 (literal -> FALSE .)
    EQUAL_TO        reduce using rule 82 (literal -> FALSE .)
    NOT_EQUAL_TO    reduce using rule 82 (literal -> FALSE .)
    LESS_THAN       reduce using rule 82 (literal -> FALSE .)
    GREATER_THAN    reduce using rule 82 (literal -> FALSE .)
    LESS_OR_EQUAL_TO reduce using rule 82 (literal -> FALSE .)
    GREATER_OR_EQUAL_TO reduce using rule 82 (literal -> FALSE .)
    SEMICOLON       reduce using rule 82 (literal -> FALSE .)
    COMMA           reduce using rule 82 (literal -> FALSE .)


state 104

    (83) new_object -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 136


state 105

    (39) block -> LCURLY new_scope stmt_section RCURLY .

    PUBLIC          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    PRIVATE         reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    ID              reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    INT             reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    FLOAT           reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    BOOLEAN         reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    VOID            reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    NULL            reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    STATIC          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    RCURLY          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    BREAK           reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    CONTINUE        reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    SEMICOLON       reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    IF              reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    WHILE           reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    FOR             reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    RETURN          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    LCURLY          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    INCREMENT       reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    DECREMENT       reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    THIS            reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    SUPER           reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    LPAREN          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    INT_CONST       reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    FLOAT_CONST     reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    STRING          reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    TRUE            reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    FALSE           reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    NEW             reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)
    ELSE            reduce using rule 39 (block -> LCURLY new_scope stmt_section RCURLY .)


state 106

    (41) stmt_section -> stmt stmt_section .

    RCURLY          reduce using rule 41 (stmt_section -> stmt stmt_section .)


state 107

    (47) stmt -> stmt_expr SEMICOLON .

    BREAK           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    IF              reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    LCURLY          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    INCREMENT       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    DECREMENT       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    VOID            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    STRING          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    RCURLY          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)


state 108

    (48) stmt -> BREAK SEMICOLON .

    BREAK           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    RCURLY          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 48 (stmt -> BREAK SEMICOLON .)


state 109

    (49) stmt -> CONTINUE SEMICOLON .

    BREAK           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    RCURLY          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)


state 110

    (53) if_stmt -> IF LPAREN . expr RPAREN stmt else_stmt
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 137
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 111

    (73) primary_expr -> LPAREN expr . RPAREN
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          shift and go to state 138
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150


state 112

    (65) expr -> primary_expr .
    (87) method_invocation -> primary_expr . DOT ID LPAREN arguments RPAREN
    (85) field_access -> primary_expr . DOT ID

    RPAREN          reduce using rule 65 (expr -> primary_expr .)
    PLUS            reduce using rule 65 (expr -> primary_expr .)
    MINUS           reduce using rule 65 (expr -> primary_expr .)
    MULTIPLY        reduce using rule 65 (expr -> primary_expr .)
    DIVIDE          reduce using rule 65 (expr -> primary_expr .)
    AND             reduce using rule 65 (expr -> primary_expr .)
    OR              reduce using rule 65 (expr -> primary_expr .)
    EQUAL_TO        reduce using rule 65 (expr -> primary_expr .)
    NOT_EQUAL_TO    reduce using rule 65 (expr -> primary_expr .)
    LESS_THAN       reduce using rule 65 (expr -> primary_expr .)
    GREATER_THAN    reduce using rule 65 (expr -> primary_expr .)
    LESS_OR_EQUAL_TO reduce using rule 65 (expr -> primary_expr .)
    GREATER_OR_EQUAL_TO reduce using rule 65 (expr -> primary_expr .)
    SEMICOLON       reduce using rule 65 (expr -> primary_expr .)
    COMMA           reduce using rule 65 (expr -> primary_expr .)
    DOT             shift and go to state 135


state 113

    (66) expr -> assign_expr .

    RPAREN          reduce using rule 66 (expr -> assign_expr .)
    PLUS            reduce using rule 66 (expr -> assign_expr .)
    MINUS           reduce using rule 66 (expr -> assign_expr .)
    MULTIPLY        reduce using rule 66 (expr -> assign_expr .)
    DIVIDE          reduce using rule 66 (expr -> assign_expr .)
    AND             reduce using rule 66 (expr -> assign_expr .)
    OR              reduce using rule 66 (expr -> assign_expr .)
    EQUAL_TO        reduce using rule 66 (expr -> assign_expr .)
    NOT_EQUAL_TO    reduce using rule 66 (expr -> assign_expr .)
    LESS_THAN       reduce using rule 66 (expr -> assign_expr .)
    GREATER_THAN    reduce using rule 66 (expr -> assign_expr .)
    LESS_OR_EQUAL_TO reduce using rule 66 (expr -> assign_expr .)
    GREATER_OR_EQUAL_TO reduce using rule 66 (expr -> assign_expr .)
    SEMICOLON       reduce using rule 66 (expr -> assign_expr .)
    COMMA           reduce using rule 66 (expr -> assign_expr .)


state 114

    (67) expr -> arith_expr .

    RPAREN          reduce using rule 67 (expr -> arith_expr .)
    PLUS            reduce using rule 67 (expr -> arith_expr .)
    MINUS           reduce using rule 67 (expr -> arith_expr .)
    MULTIPLY        reduce using rule 67 (expr -> arith_expr .)
    DIVIDE          reduce using rule 67 (expr -> arith_expr .)
    AND             reduce using rule 67 (expr -> arith_expr .)
    OR              reduce using rule 67 (expr -> arith_expr .)
    EQUAL_TO        reduce using rule 67 (expr -> arith_expr .)
    NOT_EQUAL_TO    reduce using rule 67 (expr -> arith_expr .)
    LESS_THAN       reduce using rule 67 (expr -> arith_expr .)
    GREATER_THAN    reduce using rule 67 (expr -> arith_expr .)
    LESS_OR_EQUAL_TO reduce using rule 67 (expr -> arith_expr .)
    GREATER_OR_EQUAL_TO reduce using rule 67 (expr -> arith_expr .)
    SEMICOLON       reduce using rule 67 (expr -> arith_expr .)
    COMMA           reduce using rule 67 (expr -> arith_expr .)


state 115

    (68) expr -> bool_expr .

    RPAREN          reduce using rule 68 (expr -> bool_expr .)
    PLUS            reduce using rule 68 (expr -> bool_expr .)
    MINUS           reduce using rule 68 (expr -> bool_expr .)
    MULTIPLY        reduce using rule 68 (expr -> bool_expr .)
    DIVIDE          reduce using rule 68 (expr -> bool_expr .)
    AND             reduce using rule 68 (expr -> bool_expr .)
    OR              reduce using rule 68 (expr -> bool_expr .)
    EQUAL_TO        reduce using rule 68 (expr -> bool_expr .)
    NOT_EQUAL_TO    reduce using rule 68 (expr -> bool_expr .)
    LESS_THAN       reduce using rule 68 (expr -> bool_expr .)
    GREATER_THAN    reduce using rule 68 (expr -> bool_expr .)
    LESS_OR_EQUAL_TO reduce using rule 68 (expr -> bool_expr .)
    GREATER_OR_EQUAL_TO reduce using rule 68 (expr -> bool_expr .)
    SEMICOLON       reduce using rule 68 (expr -> bool_expr .)
    COMMA           reduce using rule 68 (expr -> bool_expr .)


state 116

    (69) expr -> unary_expr .

    RPAREN          reduce using rule 69 (expr -> unary_expr .)
    PLUS            reduce using rule 69 (expr -> unary_expr .)
    MINUS           reduce using rule 69 (expr -> unary_expr .)
    MULTIPLY        reduce using rule 69 (expr -> unary_expr .)
    DIVIDE          reduce using rule 69 (expr -> unary_expr .)
    AND             reduce using rule 69 (expr -> unary_expr .)
    OR              reduce using rule 69 (expr -> unary_expr .)
    EQUAL_TO        reduce using rule 69 (expr -> unary_expr .)
    NOT_EQUAL_TO    reduce using rule 69 (expr -> unary_expr .)
    LESS_THAN       reduce using rule 69 (expr -> unary_expr .)
    GREATER_THAN    reduce using rule 69 (expr -> unary_expr .)
    LESS_OR_EQUAL_TO reduce using rule 69 (expr -> unary_expr .)
    GREATER_OR_EQUAL_TO reduce using rule 69 (expr -> unary_expr .)
    SEMICOLON       reduce using rule 69 (expr -> unary_expr .)
    COMMA           reduce using rule 69 (expr -> unary_expr .)


state 117

    (75) primary_expr -> left_hand_side .
    (92) assign_expr -> left_hand_side . ASSIGN_OP expr
    (93) assign_expr -> left_hand_side . INCREMENT
    (95) assign_expr -> left_hand_side . DECREMENT

    DOT             reduce using rule 75 (primary_expr -> left_hand_side .)
    RPAREN          reduce using rule 75 (primary_expr -> left_hand_side .)
    PLUS            reduce using rule 75 (primary_expr -> left_hand_side .)
    MINUS           reduce using rule 75 (primary_expr -> left_hand_side .)
    MULTIPLY        reduce using rule 75 (primary_expr -> left_hand_side .)
    DIVIDE          reduce using rule 75 (primary_expr -> left_hand_side .)
    AND             reduce using rule 75 (primary_expr -> left_hand_side .)
    OR              reduce using rule 75 (primary_expr -> left_hand_side .)
    EQUAL_TO        reduce using rule 75 (primary_expr -> left_hand_side .)
    NOT_EQUAL_TO    reduce using rule 75 (primary_expr -> left_hand_side .)
    LESS_THAN       reduce using rule 75 (primary_expr -> left_hand_side .)
    GREATER_THAN    reduce using rule 75 (primary_expr -> left_hand_side .)
    LESS_OR_EQUAL_TO reduce using rule 75 (primary_expr -> left_hand_side .)
    GREATER_OR_EQUAL_TO reduce using rule 75 (primary_expr -> left_hand_side .)
    SEMICOLON       reduce using rule 75 (primary_expr -> left_hand_side .)
    COMMA           reduce using rule 75 (primary_expr -> left_hand_side .)
    ASSIGN_OP       shift and go to state 129
    INCREMENT       shift and go to state 130
    DECREMENT       shift and go to state 131


state 118

    (76) primary_expr -> method_invocation .

    DOT             reduce using rule 76 (primary_expr -> method_invocation .)
    RPAREN          reduce using rule 76 (primary_expr -> method_invocation .)
    PLUS            reduce using rule 76 (primary_expr -> method_invocation .)
    MINUS           reduce using rule 76 (primary_expr -> method_invocation .)
    MULTIPLY        reduce using rule 76 (primary_expr -> method_invocation .)
    DIVIDE          reduce using rule 76 (primary_expr -> method_invocation .)
    AND             reduce using rule 76 (primary_expr -> method_invocation .)
    OR              reduce using rule 76 (primary_expr -> method_invocation .)
    EQUAL_TO        reduce using rule 76 (primary_expr -> method_invocation .)
    NOT_EQUAL_TO    reduce using rule 76 (primary_expr -> method_invocation .)
    LESS_THAN       reduce using rule 76 (primary_expr -> method_invocation .)
    GREATER_THAN    reduce using rule 76 (primary_expr -> method_invocation .)
    LESS_OR_EQUAL_TO reduce using rule 76 (primary_expr -> method_invocation .)
    GREATER_OR_EQUAL_TO reduce using rule 76 (primary_expr -> method_invocation .)
    SEMICOLON       reduce using rule 76 (primary_expr -> method_invocation .)
    COMMA           reduce using rule 76 (primary_expr -> method_invocation .)


state 119

    (109) unary_expr -> PLUS . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 151
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 120

    (110) unary_expr -> MINUS . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 152
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 121

    (111) unary_expr -> NEGATION . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 153
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 122

    (80) literal -> NULL .

    DOT             reduce using rule 80 (literal -> NULL .)
    RPAREN          reduce using rule 80 (literal -> NULL .)
    PLUS            reduce using rule 80 (literal -> NULL .)
    MINUS           reduce using rule 80 (literal -> NULL .)
    MULTIPLY        reduce using rule 80 (literal -> NULL .)
    DIVIDE          reduce using rule 80 (literal -> NULL .)
    AND             reduce using rule 80 (literal -> NULL .)
    OR              reduce using rule 80 (literal -> NULL .)
    EQUAL_TO        reduce using rule 80 (literal -> NULL .)
    NOT_EQUAL_TO    reduce using rule 80 (literal -> NULL .)
    LESS_THAN       reduce using rule 80 (literal -> NULL .)
    GREATER_THAN    reduce using rule 80 (literal -> NULL .)
    LESS_OR_EQUAL_TO reduce using rule 80 (literal -> NULL .)
    GREATER_OR_EQUAL_TO reduce using rule 80 (literal -> NULL .)
    SEMICOLON       reduce using rule 80 (literal -> NULL .)
    COMMA           reduce using rule 80 (literal -> NULL .)


state 123

    (86) field_access -> ID .

    ASSIGN_OP       reduce using rule 86 (field_access -> ID .)
    INCREMENT       reduce using rule 86 (field_access -> ID .)
    DECREMENT       reduce using rule 86 (field_access -> ID .)
    DOT             reduce using rule 86 (field_access -> ID .)
    RPAREN          reduce using rule 86 (field_access -> ID .)
    PLUS            reduce using rule 86 (field_access -> ID .)
    MINUS           reduce using rule 86 (field_access -> ID .)
    MULTIPLY        reduce using rule 86 (field_access -> ID .)
    DIVIDE          reduce using rule 86 (field_access -> ID .)
    AND             reduce using rule 86 (field_access -> ID .)
    OR              reduce using rule 86 (field_access -> ID .)
    EQUAL_TO        reduce using rule 86 (field_access -> ID .)
    NOT_EQUAL_TO    reduce using rule 86 (field_access -> ID .)
    LESS_THAN       reduce using rule 86 (field_access -> ID .)
    GREATER_THAN    reduce using rule 86 (field_access -> ID .)
    LESS_OR_EQUAL_TO reduce using rule 86 (field_access -> ID .)
    GREATER_OR_EQUAL_TO reduce using rule 86 (field_access -> ID .)
    SEMICOLON       reduce using rule 86 (field_access -> ID .)
    COMMA           reduce using rule 86 (field_access -> ID .)


state 124

    (56) while_stmt -> WHILE LPAREN . expr RPAREN stmt
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 154
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 125

    (57) for_stmt -> FOR LPAREN . optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (59) optional_stmt_expr -> . stmt_expr
    (60) optional_stmt_expr -> . empty
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (3) empty -> .
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    SEMICOLON       reduce using rule 3 (empty -> .)
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    ID              shift and go to state 123
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    optional_stmt_expr             shift and go to state 155
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 126

    (58) return_stmt -> RETURN optional_expr . SEMICOLON

    SEMICOLON       shift and go to state 158


state 127

    (61) optional_expr -> expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    SEMICOLON       reduce using rule 61 (optional_expr -> expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150


state 128

    (62) optional_expr -> empty .

    SEMICOLON       reduce using rule 62 (optional_expr -> empty .)


state 129

    (92) assign_expr -> left_hand_side ASSIGN_OP . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    left_hand_side                 shift and go to state 117
    expr                           shift and go to state 159
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 130

    (93) assign_expr -> left_hand_side INCREMENT .

    SEMICOLON       reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    RPAREN          reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    PLUS            reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    MINUS           reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    MULTIPLY        reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    DIVIDE          reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    AND             reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    OR              reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    EQUAL_TO        reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    NOT_EQUAL_TO    reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    LESS_THAN       reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    GREATER_THAN    reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    LESS_OR_EQUAL_TO reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    GREATER_OR_EQUAL_TO reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)
    COMMA           reduce using rule 93 (assign_expr -> left_hand_side INCREMENT .)


state 131

    (95) assign_expr -> left_hand_side DECREMENT .

    SEMICOLON       reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    RPAREN          reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    PLUS            reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    MINUS           reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    MULTIPLY        reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    DIVIDE          reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    AND             reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    OR              reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    EQUAL_TO        reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    NOT_EQUAL_TO    reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    LESS_THAN       reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    GREATER_THAN    reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    LESS_OR_EQUAL_TO reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    GREATER_OR_EQUAL_TO reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)
    COMMA           reduce using rule 95 (assign_expr -> left_hand_side DECREMENT .)


state 132

    (94) assign_expr -> INCREMENT left_hand_side .
    (75) primary_expr -> left_hand_side .

    SEMICOLON       reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    RPAREN          reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    PLUS            reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    MINUS           reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    MULTIPLY        reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    DIVIDE          reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    AND             reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    OR              reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    EQUAL_TO        reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    NOT_EQUAL_TO    reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    LESS_THAN       reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    GREATER_THAN    reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    LESS_OR_EQUAL_TO reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    GREATER_OR_EQUAL_TO reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    COMMA           reduce using rule 94 (assign_expr -> INCREMENT left_hand_side .)
    DOT             reduce using rule 75 (primary_expr -> left_hand_side .)


state 133

    (85) field_access -> primary_expr . DOT ID
    (87) method_invocation -> primary_expr . DOT ID LPAREN arguments RPAREN

    DOT             shift and go to state 160


state 134

    (96) assign_expr -> DECREMENT left_hand_side .
    (75) primary_expr -> left_hand_side .

    SEMICOLON       reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    RPAREN          reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    PLUS            reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    MINUS           reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    MULTIPLY        reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    DIVIDE          reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    AND             reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    OR              reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    EQUAL_TO        reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    NOT_EQUAL_TO    reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    LESS_THAN       reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    GREATER_THAN    reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    LESS_OR_EQUAL_TO reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    GREATER_OR_EQUAL_TO reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    COMMA           reduce using rule 96 (assign_expr -> DECREMENT left_hand_side .)
    DOT             reduce using rule 75 (primary_expr -> left_hand_side .)


state 135

    (87) method_invocation -> primary_expr DOT . ID LPAREN arguments RPAREN
    (85) field_access -> primary_expr DOT . ID

    ID              shift and go to state 161


state 136

    (83) new_object -> NEW ID . LPAREN arguments RPAREN

    LPAREN          shift and go to state 162


state 137

    (53) if_stmt -> IF LPAREN expr . RPAREN stmt else_stmt
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          shift and go to state 163
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150


state 138

    (73) primary_expr -> LPAREN expr RPAREN .

    DOT             reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    EQUAL_TO        reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    NOT_EQUAL_TO    reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    LESS_THAN       reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    GREATER_THAN    reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    LESS_OR_EQUAL_TO reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    GREATER_OR_EQUAL_TO reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 73 (primary_expr -> LPAREN expr RPAREN .)


state 139

    (97) arith_expr -> expr PLUS . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 164
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 140

    (98) arith_expr -> expr MINUS . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 165
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 141

    (99) arith_expr -> expr MULTIPLY . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 166
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 142

    (100) arith_expr -> expr DIVIDE . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 167
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 143

    (101) bool_expr -> expr AND . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 168
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 144

    (102) bool_expr -> expr OR . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 169
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 145

    (103) bool_expr -> expr EQUAL_TO . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 170
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 146

    (104) bool_expr -> expr NOT_EQUAL_TO . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 171
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 147

    (105) bool_expr -> expr LESS_THAN . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 172
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 148

    (106) bool_expr -> expr GREATER_THAN . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 173
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 149

    (107) bool_expr -> expr LESS_OR_EQUAL_TO . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 174
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 150

    (108) bool_expr -> expr GREATER_OR_EQUAL_TO . expr
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 175
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 151

    (109) unary_expr -> PLUS expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 109 (unary_expr -> PLUS expr .)
    PLUS            reduce using rule 109 (unary_expr -> PLUS expr .)
    MINUS           reduce using rule 109 (unary_expr -> PLUS expr .)
    MULTIPLY        reduce using rule 109 (unary_expr -> PLUS expr .)
    DIVIDE          reduce using rule 109 (unary_expr -> PLUS expr .)
    AND             reduce using rule 109 (unary_expr -> PLUS expr .)
    OR              reduce using rule 109 (unary_expr -> PLUS expr .)
    EQUAL_TO        reduce using rule 109 (unary_expr -> PLUS expr .)
    NOT_EQUAL_TO    reduce using rule 109 (unary_expr -> PLUS expr .)
    LESS_THAN       reduce using rule 109 (unary_expr -> PLUS expr .)
    GREATER_THAN    reduce using rule 109 (unary_expr -> PLUS expr .)
    LESS_OR_EQUAL_TO reduce using rule 109 (unary_expr -> PLUS expr .)
    GREATER_OR_EQUAL_TO reduce using rule 109 (unary_expr -> PLUS expr .)
    SEMICOLON       reduce using rule 109 (unary_expr -> PLUS expr .)
    COMMA           reduce using rule 109 (unary_expr -> PLUS expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 152

    (110) unary_expr -> MINUS expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 110 (unary_expr -> MINUS expr .)
    PLUS            reduce using rule 110 (unary_expr -> MINUS expr .)
    MINUS           reduce using rule 110 (unary_expr -> MINUS expr .)
    MULTIPLY        reduce using rule 110 (unary_expr -> MINUS expr .)
    DIVIDE          reduce using rule 110 (unary_expr -> MINUS expr .)
    AND             reduce using rule 110 (unary_expr -> MINUS expr .)
    OR              reduce using rule 110 (unary_expr -> MINUS expr .)
    EQUAL_TO        reduce using rule 110 (unary_expr -> MINUS expr .)
    NOT_EQUAL_TO    reduce using rule 110 (unary_expr -> MINUS expr .)
    LESS_THAN       reduce using rule 110 (unary_expr -> MINUS expr .)
    GREATER_THAN    reduce using rule 110 (unary_expr -> MINUS expr .)
    LESS_OR_EQUAL_TO reduce using rule 110 (unary_expr -> MINUS expr .)
    GREATER_OR_EQUAL_TO reduce using rule 110 (unary_expr -> MINUS expr .)
    SEMICOLON       reduce using rule 110 (unary_expr -> MINUS expr .)
    COMMA           reduce using rule 110 (unary_expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 153

    (111) unary_expr -> NEGATION expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 111 (unary_expr -> NEGATION expr .)
    PLUS            reduce using rule 111 (unary_expr -> NEGATION expr .)
    MINUS           reduce using rule 111 (unary_expr -> NEGATION expr .)
    MULTIPLY        reduce using rule 111 (unary_expr -> NEGATION expr .)
    DIVIDE          reduce using rule 111 (unary_expr -> NEGATION expr .)
    AND             reduce using rule 111 (unary_expr -> NEGATION expr .)
    OR              reduce using rule 111 (unary_expr -> NEGATION expr .)
    EQUAL_TO        reduce using rule 111 (unary_expr -> NEGATION expr .)
    NOT_EQUAL_TO    reduce using rule 111 (unary_expr -> NEGATION expr .)
    LESS_THAN       reduce using rule 111 (unary_expr -> NEGATION expr .)
    GREATER_THAN    reduce using rule 111 (unary_expr -> NEGATION expr .)
    LESS_OR_EQUAL_TO reduce using rule 111 (unary_expr -> NEGATION expr .)
    GREATER_OR_EQUAL_TO reduce using rule 111 (unary_expr -> NEGATION expr .)
    SEMICOLON       reduce using rule 111 (unary_expr -> NEGATION expr .)
    COMMA           reduce using rule 111 (unary_expr -> NEGATION expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 154

    (56) while_stmt -> WHILE LPAREN expr . RPAREN stmt
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          shift and go to state 176
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150


state 155

    (57) for_stmt -> FOR LPAREN optional_stmt_expr . SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 177


state 156

    (59) optional_stmt_expr -> stmt_expr .

    SEMICOLON       reduce using rule 59 (optional_stmt_expr -> stmt_expr .)
    RPAREN          reduce using rule 59 (optional_stmt_expr -> stmt_expr .)


state 157

    (60) optional_stmt_expr -> empty .

    SEMICOLON       reduce using rule 60 (optional_stmt_expr -> empty .)
    RPAREN          reduce using rule 60 (optional_stmt_expr -> empty .)


state 158

    (58) return_stmt -> RETURN optional_expr SEMICOLON .

    BREAK           reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    CONTINUE        reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    SEMICOLON       reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    IF              reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    WHILE           reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    FOR             reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    RETURN          reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    LCURLY          reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    INCREMENT       reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    DECREMENT       reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    INT             reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    FLOAT           reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    BOOLEAN         reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    VOID            reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    NULL            reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    ID              reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    THIS            reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    SUPER           reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    LPAREN          reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    INT_CONST       reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    STRING          reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    TRUE            reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    FALSE           reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    NEW             reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    RCURLY          reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)
    ELSE            reduce using rule 58 (return_stmt -> RETURN optional_expr SEMICOLON .)


state 159

    (92) assign_expr -> left_hand_side ASSIGN_OP expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    SEMICOLON       reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .)
    RPAREN          reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .)
    COMMA           reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150

  ! PLUS            [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! MINUS           [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! MULTIPLY        [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! DIVIDE          [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! AND             [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! OR              [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! EQUAL_TO        [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! LESS_THAN       [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! GREATER_THAN    [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! LESS_OR_EQUAL_TO [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]
  ! GREATER_OR_EQUAL_TO [ reduce using rule 92 (assign_expr -> left_hand_side ASSIGN_OP expr .) ]


state 160

    (85) field_access -> primary_expr DOT . ID
    (87) method_invocation -> primary_expr DOT . ID LPAREN arguments RPAREN

    ID              shift and go to state 178


state 161

    (87) method_invocation -> primary_expr DOT ID . LPAREN arguments RPAREN
    (85) field_access -> primary_expr DOT ID .

    LPAREN          shift and go to state 179
    ASSIGN_OP       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    INCREMENT       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    DECREMENT       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    DOT             reduce using rule 85 (field_access -> primary_expr DOT ID .)
    RPAREN          reduce using rule 85 (field_access -> primary_expr DOT ID .)
    PLUS            reduce using rule 85 (field_access -> primary_expr DOT ID .)
    MINUS           reduce using rule 85 (field_access -> primary_expr DOT ID .)
    MULTIPLY        reduce using rule 85 (field_access -> primary_expr DOT ID .)
    DIVIDE          reduce using rule 85 (field_access -> primary_expr DOT ID .)
    AND             reduce using rule 85 (field_access -> primary_expr DOT ID .)
    OR              reduce using rule 85 (field_access -> primary_expr DOT ID .)
    EQUAL_TO        reduce using rule 85 (field_access -> primary_expr DOT ID .)
    NOT_EQUAL_TO    reduce using rule 85 (field_access -> primary_expr DOT ID .)
    LESS_THAN       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    GREATER_THAN    reduce using rule 85 (field_access -> primary_expr DOT ID .)
    LESS_OR_EQUAL_TO reduce using rule 85 (field_access -> primary_expr DOT ID .)
    GREATER_OR_EQUAL_TO reduce using rule 85 (field_access -> primary_expr DOT ID .)
    SEMICOLON       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    COMMA           reduce using rule 85 (field_access -> primary_expr DOT ID .)


state 162

    (83) new_object -> NEW ID LPAREN . arguments RPAREN
    (88) arguments -> . expr additional_exprs
    (89) arguments -> . empty
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (3) empty -> .
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    RPAREN          reduce using rule 3 (empty -> .)
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    arguments                      shift and go to state 180
    expr                           shift and go to state 181
    empty                          shift and go to state 182
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 163

    (53) if_stmt -> IF LPAREN expr RPAREN . stmt else_stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . while_stmt
    (45) stmt -> . for_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) if_stmt -> . IF LPAREN expr RPAREN stmt else_stmt
    (56) while_stmt -> . WHILE LPAREN expr RPAREN stmt
    (57) for_stmt -> . FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (58) return_stmt -> . RETURN optional_expr SEMICOLON
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (39) block -> . LCURLY new_scope stmt_section RCURLY
    (20) var_decl -> . type variables SEMICOLON
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 75
    IF              shift and go to state 80
    WHILE           shift and go to state 82
    FOR             shift and go to state 83
    RETURN          shift and go to state 84
    LCURLY          shift and go to state 61
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 93
    ID              shift and go to state 92
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    stmt                           shift and go to state 183
    if_stmt                        shift and go to state 70
    while_stmt                     shift and go to state 71
    for_stmt                       shift and go to state 72
    return_stmt                    shift and go to state 73
    stmt_expr                      shift and go to state 74
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    type                           shift and go to state 87
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 164

    (97) arith_expr -> expr PLUS expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 97 (arith_expr -> expr PLUS expr .)
    PLUS            reduce using rule 97 (arith_expr -> expr PLUS expr .)
    MINUS           reduce using rule 97 (arith_expr -> expr PLUS expr .)
    AND             reduce using rule 97 (arith_expr -> expr PLUS expr .)
    OR              reduce using rule 97 (arith_expr -> expr PLUS expr .)
    EQUAL_TO        reduce using rule 97 (arith_expr -> expr PLUS expr .)
    NOT_EQUAL_TO    reduce using rule 97 (arith_expr -> expr PLUS expr .)
    LESS_THAN       reduce using rule 97 (arith_expr -> expr PLUS expr .)
    GREATER_THAN    reduce using rule 97 (arith_expr -> expr PLUS expr .)
    LESS_OR_EQUAL_TO reduce using rule 97 (arith_expr -> expr PLUS expr .)
    GREATER_OR_EQUAL_TO reduce using rule 97 (arith_expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 97 (arith_expr -> expr PLUS expr .)
    COMMA           reduce using rule 97 (arith_expr -> expr PLUS expr .)
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! MULTIPLY        [ reduce using rule 97 (arith_expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 97 (arith_expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 165

    (98) arith_expr -> expr MINUS expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 98 (arith_expr -> expr MINUS expr .)
    PLUS            reduce using rule 98 (arith_expr -> expr MINUS expr .)
    MINUS           reduce using rule 98 (arith_expr -> expr MINUS expr .)
    AND             reduce using rule 98 (arith_expr -> expr MINUS expr .)
    OR              reduce using rule 98 (arith_expr -> expr MINUS expr .)
    EQUAL_TO        reduce using rule 98 (arith_expr -> expr MINUS expr .)
    NOT_EQUAL_TO    reduce using rule 98 (arith_expr -> expr MINUS expr .)
    LESS_THAN       reduce using rule 98 (arith_expr -> expr MINUS expr .)
    GREATER_THAN    reduce using rule 98 (arith_expr -> expr MINUS expr .)
    LESS_OR_EQUAL_TO reduce using rule 98 (arith_expr -> expr MINUS expr .)
    GREATER_OR_EQUAL_TO reduce using rule 98 (arith_expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 98 (arith_expr -> expr MINUS expr .)
    COMMA           reduce using rule 98 (arith_expr -> expr MINUS expr .)
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! MULTIPLY        [ reduce using rule 98 (arith_expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 98 (arith_expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 166

    (99) arith_expr -> expr MULTIPLY expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    PLUS            reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    MINUS           reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    MULTIPLY        reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    DIVIDE          reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    AND             reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    OR              reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    EQUAL_TO        reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    NOT_EQUAL_TO    reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    LESS_THAN       reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    GREATER_THAN    reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    LESS_OR_EQUAL_TO reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    GREATER_OR_EQUAL_TO reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    SEMICOLON       reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)
    COMMA           reduce using rule 99 (arith_expr -> expr MULTIPLY expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 167

    (100) arith_expr -> expr DIVIDE expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    MULTIPLY        reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    AND             reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    OR              reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    EQUAL_TO        reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    NOT_EQUAL_TO    reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    LESS_THAN       reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    GREATER_THAN    reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    LESS_OR_EQUAL_TO reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    GREATER_OR_EQUAL_TO reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 100 (arith_expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 100 (arith_expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 168

    (101) bool_expr -> expr AND expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 101 (bool_expr -> expr AND expr .)
    AND             reduce using rule 101 (bool_expr -> expr AND expr .)
    OR              reduce using rule 101 (bool_expr -> expr AND expr .)
    SEMICOLON       reduce using rule 101 (bool_expr -> expr AND expr .)
    COMMA           reduce using rule 101 (bool_expr -> expr AND expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150

  ! PLUS            [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! MULTIPLY        [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! EQUAL_TO        [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! LESS_THAN       [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! GREATER_THAN    [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! LESS_OR_EQUAL_TO [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! GREATER_OR_EQUAL_TO [ reduce using rule 101 (bool_expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]


state 169

    (102) bool_expr -> expr OR expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 102 (bool_expr -> expr OR expr .)
    OR              reduce using rule 102 (bool_expr -> expr OR expr .)
    SEMICOLON       reduce using rule 102 (bool_expr -> expr OR expr .)
    COMMA           reduce using rule 102 (bool_expr -> expr OR expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150

  ! PLUS            [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! MULTIPLY        [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! EQUAL_TO        [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! LESS_THAN       [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! GREATER_THAN    [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! LESS_OR_EQUAL_TO [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! GREATER_OR_EQUAL_TO [ reduce using rule 102 (bool_expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 144 ]


state 170

    (103) bool_expr -> expr EQUAL_TO expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    AND             reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    OR              reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    EQUAL_TO        reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    NOT_EQUAL_TO    reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    SEMICOLON       reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    COMMA           reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150

  ! PLUS            [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! MINUS           [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! MULTIPLY        [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! DIVIDE          [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! LESS_THAN       [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! GREATER_THAN    [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! LESS_OR_EQUAL_TO [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! GREATER_OR_EQUAL_TO [ reduce using rule 103 (bool_expr -> expr EQUAL_TO expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]


state 171

    (104) bool_expr -> expr NOT_EQUAL_TO expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    AND             reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    OR              reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    EQUAL_TO        reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    NOT_EQUAL_TO    reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    SEMICOLON       reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    COMMA           reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150

  ! PLUS            [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! MINUS           [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! MULTIPLY        [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! DIVIDE          [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! LESS_THAN       [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! GREATER_THAN    [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! LESS_OR_EQUAL_TO [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! GREATER_OR_EQUAL_TO [ reduce using rule 104 (bool_expr -> expr NOT_EQUAL_TO expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]


state 172

    (105) bool_expr -> expr LESS_THAN expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    AND             reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    OR              reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    EQUAL_TO        reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    NOT_EQUAL_TO    reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    LESS_THAN       reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    GREATER_THAN    reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    LESS_OR_EQUAL_TO reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    GREATER_OR_EQUAL_TO reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    SEMICOLON       reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    COMMA           reduce using rule 105 (bool_expr -> expr LESS_THAN expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 105 (bool_expr -> expr LESS_THAN expr .) ]
  ! MINUS           [ reduce using rule 105 (bool_expr -> expr LESS_THAN expr .) ]
  ! MULTIPLY        [ reduce using rule 105 (bool_expr -> expr LESS_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 105 (bool_expr -> expr LESS_THAN expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 173

    (106) bool_expr -> expr GREATER_THAN expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    AND             reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    OR              reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    EQUAL_TO        reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    NOT_EQUAL_TO    reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    LESS_THAN       reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    GREATER_THAN    reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    LESS_OR_EQUAL_TO reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    GREATER_OR_EQUAL_TO reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    SEMICOLON       reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    COMMA           reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .) ]
  ! MINUS           [ reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .) ]
  ! MULTIPLY        [ reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 106 (bool_expr -> expr GREATER_THAN expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 174

    (107) bool_expr -> expr LESS_OR_EQUAL_TO expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    AND             reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    OR              reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    EQUAL_TO        reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    NOT_EQUAL_TO    reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    LESS_THAN       reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    GREATER_THAN    reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    LESS_OR_EQUAL_TO reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    GREATER_OR_EQUAL_TO reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    SEMICOLON       reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    COMMA           reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .) ]
  ! MINUS           [ reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .) ]
  ! MULTIPLY        [ reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .) ]
  ! DIVIDE          [ reduce using rule 107 (bool_expr -> expr LESS_OR_EQUAL_TO expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 175

    (108) bool_expr -> expr GREATER_OR_EQUAL_TO expr .
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr

    RPAREN          reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    AND             reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    OR              reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    EQUAL_TO        reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    NOT_EQUAL_TO    reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    LESS_THAN       reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    GREATER_THAN    reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    LESS_OR_EQUAL_TO reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    GREATER_OR_EQUAL_TO reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    SEMICOLON       reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    COMMA           reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .) ]
  ! MINUS           [ reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .) ]
  ! MULTIPLY        [ reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .) ]
  ! DIVIDE          [ reduce using rule 108 (bool_expr -> expr GREATER_OR_EQUAL_TO expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EQUAL_TO        [ shift and go to state 145 ]
  ! NOT_EQUAL_TO    [ shift and go to state 146 ]
  ! LESS_THAN       [ shift and go to state 147 ]
  ! GREATER_THAN    [ shift and go to state 148 ]
  ! LESS_OR_EQUAL_TO [ shift and go to state 149 ]
  ! GREATER_OR_EQUAL_TO [ shift and go to state 150 ]


state 176

    (56) while_stmt -> WHILE LPAREN expr RPAREN . stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . while_stmt
    (45) stmt -> . for_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) if_stmt -> . IF LPAREN expr RPAREN stmt else_stmt
    (56) while_stmt -> . WHILE LPAREN expr RPAREN stmt
    (57) for_stmt -> . FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (58) return_stmt -> . RETURN optional_expr SEMICOLON
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (39) block -> . LCURLY new_scope stmt_section RCURLY
    (20) var_decl -> . type variables SEMICOLON
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 75
    IF              shift and go to state 80
    WHILE           shift and go to state 82
    FOR             shift and go to state 83
    RETURN          shift and go to state 84
    LCURLY          shift and go to state 61
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 93
    ID              shift and go to state 92
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    stmt                           shift and go to state 184
    if_stmt                        shift and go to state 70
    while_stmt                     shift and go to state 71
    for_stmt                       shift and go to state 72
    return_stmt                    shift and go to state 73
    stmt_expr                      shift and go to state 74
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    type                           shift and go to state 87
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 177

    (57) for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON . optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (61) optional_expr -> . expr
    (62) optional_expr -> . empty
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (3) empty -> .
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    SEMICOLON       reduce using rule 3 (empty -> .)
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    optional_expr                  shift and go to state 185
    expr                           shift and go to state 127
    empty                          shift and go to state 128
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 178

    (85) field_access -> primary_expr DOT ID .
    (87) method_invocation -> primary_expr DOT ID . LPAREN arguments RPAREN

    SEMICOLON       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    RPAREN          reduce using rule 85 (field_access -> primary_expr DOT ID .)
    PLUS            reduce using rule 85 (field_access -> primary_expr DOT ID .)
    MINUS           reduce using rule 85 (field_access -> primary_expr DOT ID .)
    MULTIPLY        reduce using rule 85 (field_access -> primary_expr DOT ID .)
    DIVIDE          reduce using rule 85 (field_access -> primary_expr DOT ID .)
    AND             reduce using rule 85 (field_access -> primary_expr DOT ID .)
    OR              reduce using rule 85 (field_access -> primary_expr DOT ID .)
    EQUAL_TO        reduce using rule 85 (field_access -> primary_expr DOT ID .)
    NOT_EQUAL_TO    reduce using rule 85 (field_access -> primary_expr DOT ID .)
    LESS_THAN       reduce using rule 85 (field_access -> primary_expr DOT ID .)
    GREATER_THAN    reduce using rule 85 (field_access -> primary_expr DOT ID .)
    LESS_OR_EQUAL_TO reduce using rule 85 (field_access -> primary_expr DOT ID .)
    GREATER_OR_EQUAL_TO reduce using rule 85 (field_access -> primary_expr DOT ID .)
    DOT             reduce using rule 85 (field_access -> primary_expr DOT ID .)
    COMMA           reduce using rule 85 (field_access -> primary_expr DOT ID .)
    LPAREN          shift and go to state 179


state 179

    (87) method_invocation -> primary_expr DOT ID LPAREN . arguments RPAREN
    (88) arguments -> . expr additional_exprs
    (89) arguments -> . empty
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (3) empty -> .
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    RPAREN          reduce using rule 3 (empty -> .)
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    primary_expr                   shift and go to state 112
    arguments                      shift and go to state 186
    expr                           shift and go to state 181
    empty                          shift and go to state 182
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 180

    (83) new_object -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 187


state 181

    (88) arguments -> expr . additional_exprs
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr
    (90) additional_exprs -> . COMMA expr additional_exprs
    (91) additional_exprs -> . empty
    (3) empty -> .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150
    COMMA           shift and go to state 189
    RPAREN          reduce using rule 3 (empty -> .)

    additional_exprs               shift and go to state 188
    empty                          shift and go to state 190

state 182

    (89) arguments -> empty .

    RPAREN          reduce using rule 89 (arguments -> empty .)


state 183

    (53) if_stmt -> IF LPAREN expr RPAREN stmt . else_stmt
    (54) else_stmt -> . ELSE stmt
    (55) else_stmt -> . empty
    (3) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 192
    BREAK           reduce using rule 3 (empty -> .)
    CONTINUE        reduce using rule 3 (empty -> .)
    SEMICOLON       reduce using rule 3 (empty -> .)
    IF              reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FOR             reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    LCURLY          reduce using rule 3 (empty -> .)
    INCREMENT       reduce using rule 3 (empty -> .)
    DECREMENT       reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)
    VOID            reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    THIS            reduce using rule 3 (empty -> .)
    SUPER           reduce using rule 3 (empty -> .)
    LPAREN          reduce using rule 3 (empty -> .)
    INT_CONST       reduce using rule 3 (empty -> .)
    FLOAT_CONST     reduce using rule 3 (empty -> .)
    STRING          reduce using rule 3 (empty -> .)
    TRUE            reduce using rule 3 (empty -> .)
    FALSE           reduce using rule 3 (empty -> .)
    NEW             reduce using rule 3 (empty -> .)
    RCURLY          reduce using rule 3 (empty -> .)

  ! ELSE            [ reduce using rule 3 (empty -> .) ]

    else_stmt                      shift and go to state 191
    empty                          shift and go to state 193

state 184

    (56) while_stmt -> WHILE LPAREN expr RPAREN stmt .

    BREAK           reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    INCREMENT       reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    DECREMENT       reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    VOID            reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    RCURLY          reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 56 (while_stmt -> WHILE LPAREN expr RPAREN stmt .)


state 185

    (57) for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr . SEMICOLON optional_stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 194


state 186

    (87) method_invocation -> primary_expr DOT ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 195


state 187

    (83) new_object -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    MULTIPLY        reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    EQUAL_TO        reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    NOT_EQUAL_TO    reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    LESS_THAN       reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    GREATER_THAN    reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    LESS_OR_EQUAL_TO reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    GREATER_OR_EQUAL_TO reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 83 (new_object -> NEW ID LPAREN arguments RPAREN .)


state 188

    (88) arguments -> expr additional_exprs .

    RPAREN          reduce using rule 88 (arguments -> expr additional_exprs .)


state 189

    (90) additional_exprs -> COMMA . expr additional_exprs
    (65) expr -> . primary_expr
    (66) expr -> . assign_expr
    (67) expr -> . arith_expr
    (68) expr -> . bool_expr
    (69) expr -> . unary_expr
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (97) arith_expr -> . expr PLUS expr
    (98) arith_expr -> . expr MINUS expr
    (99) arith_expr -> . expr MULTIPLY expr
    (100) arith_expr -> . expr DIVIDE expr
    (101) bool_expr -> . expr AND expr
    (102) bool_expr -> . expr OR expr
    (103) bool_expr -> . expr EQUAL_TO expr
    (104) bool_expr -> . expr NOT_EQUAL_TO expr
    (105) bool_expr -> . expr LESS_THAN expr
    (106) bool_expr -> . expr GREATER_THAN expr
    (107) bool_expr -> . expr LESS_OR_EQUAL_TO expr
    (108) bool_expr -> . expr GREATER_OR_EQUAL_TO expr
    (109) unary_expr -> . PLUS expr
    (110) unary_expr -> . MINUS expr
    (111) unary_expr -> . NEGATION expr
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    NEGATION        shift and go to state 121
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104
    ID              shift and go to state 123

    expr                           shift and go to state 196
    primary_expr                   shift and go to state 112
    assign_expr                    shift and go to state 113
    arith_expr                     shift and go to state 114
    bool_expr                      shift and go to state 115
    unary_expr                     shift and go to state 116
    literal                        shift and go to state 95
    new_object                     shift and go to state 98
    left_hand_side                 shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 94

state 190

    (91) additional_exprs -> empty .

    RPAREN          reduce using rule 91 (additional_exprs -> empty .)


state 191

    (53) if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .

    BREAK           reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    CONTINUE        reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    SEMICOLON       reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    IF              reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    WHILE           reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    FOR             reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    RETURN          reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    LCURLY          reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    INCREMENT       reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    DECREMENT       reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    INT             reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    FLOAT           reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    BOOLEAN         reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    VOID            reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    NULL            reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    ID              reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    THIS            reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    SUPER           reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    LPAREN          reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    INT_CONST       reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    FLOAT_CONST     reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    STRING          reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    TRUE            reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    FALSE           reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    NEW             reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    RCURLY          reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)
    ELSE            reduce using rule 53 (if_stmt -> IF LPAREN expr RPAREN stmt else_stmt .)


state 192

    (54) else_stmt -> ELSE . stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . while_stmt
    (45) stmt -> . for_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) if_stmt -> . IF LPAREN expr RPAREN stmt else_stmt
    (56) while_stmt -> . WHILE LPAREN expr RPAREN stmt
    (57) for_stmt -> . FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (58) return_stmt -> . RETURN optional_expr SEMICOLON
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (39) block -> . LCURLY new_scope stmt_section RCURLY
    (20) var_decl -> . type variables SEMICOLON
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 75
    IF              shift and go to state 80
    WHILE           shift and go to state 82
    FOR             shift and go to state 83
    RETURN          shift and go to state 84
    LCURLY          shift and go to state 61
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 93
    ID              shift and go to state 92
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    stmt                           shift and go to state 197
    if_stmt                        shift and go to state 70
    while_stmt                     shift and go to state 71
    for_stmt                       shift and go to state 72
    return_stmt                    shift and go to state 73
    stmt_expr                      shift and go to state 74
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    type                           shift and go to state 87
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 193

    (55) else_stmt -> empty .

    ELSE            reduce using rule 55 (else_stmt -> empty .)
    BREAK           reduce using rule 55 (else_stmt -> empty .)
    CONTINUE        reduce using rule 55 (else_stmt -> empty .)
    SEMICOLON       reduce using rule 55 (else_stmt -> empty .)
    IF              reduce using rule 55 (else_stmt -> empty .)
    WHILE           reduce using rule 55 (else_stmt -> empty .)
    FOR             reduce using rule 55 (else_stmt -> empty .)
    RETURN          reduce using rule 55 (else_stmt -> empty .)
    LCURLY          reduce using rule 55 (else_stmt -> empty .)
    INCREMENT       reduce using rule 55 (else_stmt -> empty .)
    DECREMENT       reduce using rule 55 (else_stmt -> empty .)
    INT             reduce using rule 55 (else_stmt -> empty .)
    FLOAT           reduce using rule 55 (else_stmt -> empty .)
    BOOLEAN         reduce using rule 55 (else_stmt -> empty .)
    VOID            reduce using rule 55 (else_stmt -> empty .)
    NULL            reduce using rule 55 (else_stmt -> empty .)
    ID              reduce using rule 55 (else_stmt -> empty .)
    THIS            reduce using rule 55 (else_stmt -> empty .)
    SUPER           reduce using rule 55 (else_stmt -> empty .)
    LPAREN          reduce using rule 55 (else_stmt -> empty .)
    INT_CONST       reduce using rule 55 (else_stmt -> empty .)
    FLOAT_CONST     reduce using rule 55 (else_stmt -> empty .)
    STRING          reduce using rule 55 (else_stmt -> empty .)
    TRUE            reduce using rule 55 (else_stmt -> empty .)
    FALSE           reduce using rule 55 (else_stmt -> empty .)
    NEW             reduce using rule 55 (else_stmt -> empty .)
    RCURLY          reduce using rule 55 (else_stmt -> empty .)


state 194

    (57) for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON . optional_stmt_expr RPAREN stmt
    (59) optional_stmt_expr -> . stmt_expr
    (60) optional_stmt_expr -> . empty
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (3) empty -> .
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    RPAREN          reduce using rule 3 (empty -> .)
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    ID              shift and go to state 123
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    NULL            shift and go to state 122
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    optional_stmt_expr             shift and go to state 198
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 195

    (87) method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    DOT             reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    MULTIPLY        reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    AND             reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    OR              reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    EQUAL_TO        reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    NOT_EQUAL_TO    reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    LESS_THAN       reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    GREATER_THAN    reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    LESS_OR_EQUAL_TO reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    GREATER_OR_EQUAL_TO reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 87 (method_invocation -> primary_expr DOT ID LPAREN arguments RPAREN .)


state 196

    (90) additional_exprs -> COMMA expr . additional_exprs
    (97) arith_expr -> expr . PLUS expr
    (98) arith_expr -> expr . MINUS expr
    (99) arith_expr -> expr . MULTIPLY expr
    (100) arith_expr -> expr . DIVIDE expr
    (101) bool_expr -> expr . AND expr
    (102) bool_expr -> expr . OR expr
    (103) bool_expr -> expr . EQUAL_TO expr
    (104) bool_expr -> expr . NOT_EQUAL_TO expr
    (105) bool_expr -> expr . LESS_THAN expr
    (106) bool_expr -> expr . GREATER_THAN expr
    (107) bool_expr -> expr . LESS_OR_EQUAL_TO expr
    (108) bool_expr -> expr . GREATER_OR_EQUAL_TO expr
    (90) additional_exprs -> . COMMA expr additional_exprs
    (91) additional_exprs -> . empty
    (3) empty -> .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUAL_TO        shift and go to state 145
    NOT_EQUAL_TO    shift and go to state 146
    LESS_THAN       shift and go to state 147
    GREATER_THAN    shift and go to state 148
    LESS_OR_EQUAL_TO shift and go to state 149
    GREATER_OR_EQUAL_TO shift and go to state 150
    COMMA           shift and go to state 189
    RPAREN          reduce using rule 3 (empty -> .)

    additional_exprs               shift and go to state 199
    empty                          shift and go to state 190

state 197

    (54) else_stmt -> ELSE stmt .

    ELSE            reduce using rule 54 (else_stmt -> ELSE stmt .)
    BREAK           reduce using rule 54 (else_stmt -> ELSE stmt .)
    CONTINUE        reduce using rule 54 (else_stmt -> ELSE stmt .)
    SEMICOLON       reduce using rule 54 (else_stmt -> ELSE stmt .)
    IF              reduce using rule 54 (else_stmt -> ELSE stmt .)
    WHILE           reduce using rule 54 (else_stmt -> ELSE stmt .)
    FOR             reduce using rule 54 (else_stmt -> ELSE stmt .)
    RETURN          reduce using rule 54 (else_stmt -> ELSE stmt .)
    LCURLY          reduce using rule 54 (else_stmt -> ELSE stmt .)
    INCREMENT       reduce using rule 54 (else_stmt -> ELSE stmt .)
    DECREMENT       reduce using rule 54 (else_stmt -> ELSE stmt .)
    INT             reduce using rule 54 (else_stmt -> ELSE stmt .)
    FLOAT           reduce using rule 54 (else_stmt -> ELSE stmt .)
    BOOLEAN         reduce using rule 54 (else_stmt -> ELSE stmt .)
    VOID            reduce using rule 54 (else_stmt -> ELSE stmt .)
    NULL            reduce using rule 54 (else_stmt -> ELSE stmt .)
    ID              reduce using rule 54 (else_stmt -> ELSE stmt .)
    THIS            reduce using rule 54 (else_stmt -> ELSE stmt .)
    SUPER           reduce using rule 54 (else_stmt -> ELSE stmt .)
    LPAREN          reduce using rule 54 (else_stmt -> ELSE stmt .)
    INT_CONST       reduce using rule 54 (else_stmt -> ELSE stmt .)
    FLOAT_CONST     reduce using rule 54 (else_stmt -> ELSE stmt .)
    STRING          reduce using rule 54 (else_stmt -> ELSE stmt .)
    TRUE            reduce using rule 54 (else_stmt -> ELSE stmt .)
    FALSE           reduce using rule 54 (else_stmt -> ELSE stmt .)
    NEW             reduce using rule 54 (else_stmt -> ELSE stmt .)
    RCURLY          reduce using rule 54 (else_stmt -> ELSE stmt .)


state 198

    (57) for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 200


state 199

    (90) additional_exprs -> COMMA expr additional_exprs .

    RPAREN          reduce using rule 90 (additional_exprs -> COMMA expr additional_exprs .)


state 200

    (57) for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN . stmt
    (43) stmt -> . if_stmt
    (44) stmt -> . while_stmt
    (45) stmt -> . for_stmt
    (46) stmt -> . return_stmt
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) if_stmt -> . IF LPAREN expr RPAREN stmt else_stmt
    (56) while_stmt -> . WHILE LPAREN expr RPAREN stmt
    (57) for_stmt -> . FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt
    (58) return_stmt -> . RETURN optional_expr SEMICOLON
    (63) stmt_expr -> . assign_expr
    (64) stmt_expr -> . method_invocation
    (39) block -> . LCURLY new_scope stmt_section RCURLY
    (20) var_decl -> . type variables SEMICOLON
    (92) assign_expr -> . left_hand_side ASSIGN_OP expr
    (93) assign_expr -> . left_hand_side INCREMENT
    (94) assign_expr -> . INCREMENT left_hand_side
    (95) assign_expr -> . left_hand_side DECREMENT
    (96) assign_expr -> . DECREMENT left_hand_side
    (87) method_invocation -> . primary_expr DOT ID LPAREN arguments RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . VOID
    (25) type -> . NULL
    (26) type -> . ID
    (84) left_hand_side -> . field_access
    (70) primary_expr -> . literal
    (71) primary_expr -> . THIS
    (72) primary_expr -> . SUPER
    (73) primary_expr -> . LPAREN expr RPAREN
    (74) primary_expr -> . new_object
    (75) primary_expr -> . left_hand_side
    (76) primary_expr -> . method_invocation
    (85) field_access -> . primary_expr DOT ID
    (86) field_access -> . ID
    (77) literal -> . INT_CONST
    (78) literal -> . FLOAT_CONST
    (79) literal -> . STRING
    (80) literal -> . NULL
    (81) literal -> . TRUE
    (82) literal -> . FALSE
    (83) new_object -> . NEW ID LPAREN arguments RPAREN

    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 75
    IF              shift and go to state 80
    WHILE           shift and go to state 82
    FOR             shift and go to state 83
    RETURN          shift and go to state 84
    LCURLY          shift and go to state 61
    INCREMENT       shift and go to state 89
    DECREMENT       shift and go to state 90
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    VOID            shift and go to state 31
    NULL            shift and go to state 93
    ID              shift and go to state 92
    THIS            shift and go to state 96
    SUPER           shift and go to state 97
    LPAREN          shift and go to state 81
    INT_CONST       shift and go to state 99
    FLOAT_CONST     shift and go to state 100
    STRING          shift and go to state 101
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    NEW             shift and go to state 104

    stmt                           shift and go to state 201
    if_stmt                        shift and go to state 70
    while_stmt                     shift and go to state 71
    for_stmt                       shift and go to state 72
    return_stmt                    shift and go to state 73
    stmt_expr                      shift and go to state 74
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign_expr                    shift and go to state 85
    method_invocation              shift and go to state 86
    type                           shift and go to state 87
    left_hand_side                 shift and go to state 88
    primary_expr                   shift and go to state 91
    field_access                   shift and go to state 94
    literal                        shift and go to state 95
    new_object                     shift and go to state 98

state 201

    (57) for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .

    BREAK           reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    IF              reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    FOR             reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    LCURLY          reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    INCREMENT       reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    DECREMENT       reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    INT             reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    VOID            reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    NULL            reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    ID              reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    THIS            reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    INT_CONST       reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    STRING          reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    NEW             reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    RCURLY          reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 57 (for_stmt -> FOR LPAREN optional_stmt_expr SEMICOLON optional_expr SEMICOLON optional_stmt_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 183 resolved as shift
